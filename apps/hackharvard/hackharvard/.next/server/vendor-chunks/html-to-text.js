"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/html-to-text";
exports.ids = ["vendor-chunks/html-to-text"];
exports.modules = {

/***/ "(rsc)/../../../../node_modules/html-to-text/lib/html-to-text.cjs":
/*!******************************************************************!*\
  !*** ../../../../node_modules/html-to-text/lib/html-to-text.cjs ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar pluginHtmlparser2 = __webpack_require__(/*! @selderee/plugin-htmlparser2 */ \"(rsc)/../../../../node_modules/@selderee/plugin-htmlparser2/lib/hp2-builder.cjs\");\nvar htmlparser2 = __webpack_require__(/*! htmlparser2 */ \"(rsc)/../../../../node_modules/htmlparser2/lib/index.js\");\nvar selderee = __webpack_require__(/*! selderee */ \"(rsc)/../../../../node_modules/selderee/lib/selderee.cjs\");\nvar merge = __webpack_require__(/*! deepmerge */ \"(rsc)/../../../../node_modules/deepmerge/dist/cjs.js\");\nvar domSerializer = __webpack_require__(/*! dom-serializer */ \"(rsc)/../../../../node_modules/dom-serializer/lib/index.js\");\nfunction _interopDefaultLegacy(e) {\n    return e && typeof e === \"object\" && \"default\" in e ? e : {\n        \"default\": e\n    };\n}\nvar merge__default = /*#__PURE__*/ _interopDefaultLegacy(merge);\n/**\n * Make a recursive function that will only run to a given depth\n * and switches to an alternative function at that depth. \\\n * No limitation if `n` is `undefined` (Just wraps `f` in that case).\n *\n * @param   { number | undefined } n   Allowed depth of recursion. `undefined` for no limitation.\n * @param   { Function }           f   Function that accepts recursive callback as the first argument.\n * @param   { Function }           [g] Function to run instead, when maximum depth was reached. Do nothing by default.\n * @returns { Function }\n */ function limitedDepthRecursive(n, f, g = ()=>undefined) {\n    if (n === undefined) {\n        const f1 = function(...args) {\n            return f(f1, ...args);\n        };\n        return f1;\n    }\n    if (n >= 0) {\n        return function(...args) {\n            return f(limitedDepthRecursive(n - 1, f, g), ...args);\n        };\n    }\n    return g;\n}\n/**\n * Return the same string or a substring with\n * the given character occurrences removed from each side.\n *\n * @param   { string } str  A string to trim.\n * @param   { string } char A character to be trimmed.\n * @returns { string }\n */ function trimCharacter(str, char) {\n    let start = 0;\n    let end = str.length;\n    while(start < end && str[start] === char){\n        ++start;\n    }\n    while(end > start && str[end - 1] === char){\n        --end;\n    }\n    return start > 0 || end < str.length ? str.substring(start, end) : str;\n}\n/**\n * Return the same string or a substring with\n * the given character occurrences removed from the end only.\n *\n * @param   { string } str  A string to trim.\n * @param   { string } char A character to be trimmed.\n * @returns { string }\n */ function trimCharacterEnd(str, char) {\n    let end = str.length;\n    while(end > 0 && str[end - 1] === char){\n        --end;\n    }\n    return end < str.length ? str.substring(0, end) : str;\n}\n/**\n * Return a new string will all characters replaced with unicode escape sequences.\n * This extreme kind of escaping can used to be safely compose regular expressions.\n *\n * @param { string } str A string to escape.\n * @returns { string } A string of unicode escape sequences.\n */ function unicodeEscape(str) {\n    return str.replace(/[\\s\\S]/g, (c)=>\"\\\\u\" + c.charCodeAt().toString(16).padStart(4, \"0\"));\n}\n/**\n * Deduplicate an array by a given key callback.\n * Item properties are merged recursively and with the preference for last defined values.\n * Of items with the same key, merged item takes the place of the last item,\n * others are omitted.\n *\n * @param { any[] } items An array to deduplicate.\n * @param { (x: any) => string } getKey Callback to get a value that distinguishes unique items.\n * @returns { any[] }\n */ function mergeDuplicatesPreferLast(items, getKey) {\n    const map = new Map();\n    for(let i = items.length; i-- > 0;){\n        const item = items[i];\n        const key = getKey(item);\n        map.set(key, map.has(key) ? merge__default[\"default\"](item, map.get(key), {\n            arrayMerge: overwriteMerge$1\n        }) : item);\n    }\n    return [\n        ...map.values()\n    ].reverse();\n}\nconst overwriteMerge$1 = (acc, src, options)=>[\n        ...src\n    ];\n/**\n * Get a nested property from an object.\n *\n * @param   { object }   obj  The object to query for the value.\n * @param   { string[] } path The path to the property.\n * @returns { any }\n */ function get(obj, path) {\n    for (const key of path){\n        if (!obj) {\n            return undefined;\n        }\n        obj = obj[key];\n    }\n    return obj;\n}\n/**\n * Convert a number into alphabetic sequence representation (Sequence without zeroes).\n *\n * For example: `a, ..., z, aa, ..., zz, aaa, ...`.\n *\n * @param   { number } num              Number to convert. Must be >= 1.\n * @param   { string } [baseChar = 'a'] Character for 1 in the sequence.\n * @param   { number } [base = 26]      Number of characters in the sequence.\n * @returns { string }\n */ function numberToLetterSequence(num, baseChar = \"a\", base = 26) {\n    const digits = [];\n    do {\n        num -= 1;\n        digits.push(num % base);\n        num = num / base >> 0; // quick `floor`\n    }while (num > 0);\n    const baseCode = baseChar.charCodeAt(0);\n    return digits.reverse().map((n)=>String.fromCharCode(baseCode + n)).join(\"\");\n}\nconst I = [\n    \"I\",\n    \"X\",\n    \"C\",\n    \"M\"\n];\nconst V = [\n    \"V\",\n    \"L\",\n    \"D\"\n];\n/**\n * Convert a number to it's Roman representation. No large numbers extension.\n *\n * @param   { number } num Number to convert. `0 < num <= 3999`.\n * @returns { string }\n */ function numberToRoman(num) {\n    return [\n        ...num + \"\"\n    ].map((n)=>+n).reverse().map((v, i)=>v % 5 < 4 ? (v < 5 ? \"\" : V[i]) + I[i].repeat(v % 5) : I[i] + (v < 5 ? V[i] : I[i + 1])).reverse().join(\"\");\n}\n/**\n * Helps to build text from words.\n */ class InlineTextBuilder {\n    /**\n   * Creates an instance of InlineTextBuilder.\n   *\n   * If `maxLineLength` is not provided then it is either `options.wordwrap` or unlimited.\n   *\n   * @param { Options } options           HtmlToText options.\n   * @param { number }  [ maxLineLength ] This builder will try to wrap text to fit this line length.\n   */ constructor(options, maxLineLength = undefined){\n        /** @type { string[][] } */ this.lines = [];\n        /** @type { string[] }   */ this.nextLineWords = [];\n        this.maxLineLength = maxLineLength || options.wordwrap || Number.MAX_VALUE;\n        this.nextLineAvailableChars = this.maxLineLength;\n        this.wrapCharacters = get(options, [\n            \"longWordSplit\",\n            \"wrapCharacters\"\n        ]) || [];\n        this.forceWrapOnLimit = get(options, [\n            \"longWordSplit\",\n            \"forceWrapOnLimit\"\n        ]) || false;\n        this.stashedSpace = false;\n        this.wordBreakOpportunity = false;\n    }\n    /**\n   * Add a new word.\n   *\n   * @param { string } word A word to add.\n   * @param { boolean } [noWrap] Don't wrap text even if the line is too long.\n   */ pushWord(word, noWrap = false) {\n        if (this.nextLineAvailableChars <= 0 && !noWrap) {\n            this.startNewLine();\n        }\n        const isLineStart = this.nextLineWords.length === 0;\n        const cost = word.length + (isLineStart ? 0 : 1);\n        if (cost <= this.nextLineAvailableChars || noWrap) {\n            this.nextLineWords.push(word);\n            this.nextLineAvailableChars -= cost;\n        } else {\n            // The word is moved to a new line - prefer to wrap between words.\n            const [first, ...rest] = this.splitLongWord(word);\n            if (!isLineStart) {\n                this.startNewLine();\n            }\n            this.nextLineWords.push(first);\n            this.nextLineAvailableChars -= first.length;\n            for (const part of rest){\n                this.startNewLine();\n                this.nextLineWords.push(part);\n                this.nextLineAvailableChars -= part.length;\n            }\n        }\n    }\n    /**\n   * Pop a word from the currently built line.\n   * This doesn't affect completed lines.\n   *\n   * @returns { string }\n   */ popWord() {\n        const lastWord = this.nextLineWords.pop();\n        if (lastWord !== undefined) {\n            const isLineStart = this.nextLineWords.length === 0;\n            const cost = lastWord.length + (isLineStart ? 0 : 1);\n            this.nextLineAvailableChars += cost;\n        }\n        return lastWord;\n    }\n    /**\n   * Concat a word to the last word already in the builder.\n   * Adds a new word in case there are no words yet in the last line.\n   *\n   * @param { string } word A word to be concatenated.\n   * @param { boolean } [noWrap] Don't wrap text even if the line is too long.\n   */ concatWord(word, noWrap = false) {\n        if (this.wordBreakOpportunity && word.length > this.nextLineAvailableChars) {\n            this.pushWord(word, noWrap);\n            this.wordBreakOpportunity = false;\n        } else {\n            const lastWord = this.popWord();\n            this.pushWord(lastWord ? lastWord.concat(word) : word, noWrap);\n        }\n    }\n    /**\n   * Add current line (and more empty lines if provided argument > 1) to the list of complete lines and start a new one.\n   *\n   * @param { number } n Number of line breaks that will be added to the resulting string.\n   */ startNewLine(n = 1) {\n        this.lines.push(this.nextLineWords);\n        if (n > 1) {\n            this.lines.push(...Array.from({\n                length: n - 1\n            }, ()=>[]));\n        }\n        this.nextLineWords = [];\n        this.nextLineAvailableChars = this.maxLineLength;\n    }\n    /**\n   * No words in this builder.\n   *\n   * @returns { boolean }\n   */ isEmpty() {\n        return this.lines.length === 0 && this.nextLineWords.length === 0;\n    }\n    clear() {\n        this.lines.length = 0;\n        this.nextLineWords.length = 0;\n        this.nextLineAvailableChars = this.maxLineLength;\n    }\n    /**\n   * Join all lines of words inside the InlineTextBuilder into a complete string.\n   *\n   * @returns { string }\n   */ toString() {\n        return [\n            ...this.lines,\n            this.nextLineWords\n        ].map((words)=>words.join(\" \")).join(\"\\n\");\n    }\n    /**\n   * Split a long word up to fit within the word wrap limit.\n   * Use either a character to split looking back from the word wrap limit,\n   * or truncate to the word wrap limit.\n   *\n   * @param   { string }   word Input word.\n   * @returns { string[] }      Parts of the word.\n   */ splitLongWord(word) {\n        const parts = [];\n        let idx = 0;\n        while(word.length > this.maxLineLength){\n            const firstLine = word.substring(0, this.maxLineLength);\n            const remainingChars = word.substring(this.maxLineLength);\n            const splitIndex = firstLine.lastIndexOf(this.wrapCharacters[idx]);\n            if (splitIndex > -1) {\n                word = firstLine.substring(splitIndex + 1) + remainingChars;\n                parts.push(firstLine.substring(0, splitIndex + 1));\n            } else {\n                idx++;\n                if (idx < this.wrapCharacters.length) {\n                    word = firstLine + remainingChars;\n                } else {\n                    if (this.forceWrapOnLimit) {\n                        parts.push(firstLine);\n                        word = remainingChars;\n                        if (word.length > this.maxLineLength) {\n                            continue;\n                        }\n                    } else {\n                        word = firstLine + remainingChars;\n                    }\n                    break;\n                }\n            }\n        }\n        parts.push(word); // Add remaining part to array\n        return parts;\n    }\n}\n/* eslint-disable max-classes-per-file */ class StackItem {\n    constructor(next = null){\n        this.next = next;\n    }\n    getRoot() {\n        return this.next ? this.next : this;\n    }\n}\nclass BlockStackItem extends StackItem {\n    constructor(options, next = null, leadingLineBreaks = 1, maxLineLength = undefined){\n        super(next);\n        this.leadingLineBreaks = leadingLineBreaks;\n        this.inlineTextBuilder = new InlineTextBuilder(options, maxLineLength);\n        this.rawText = \"\";\n        this.stashedLineBreaks = 0;\n        this.isPre = next && next.isPre;\n        this.isNoWrap = next && next.isNoWrap;\n    }\n}\nclass ListStackItem extends BlockStackItem {\n    constructor(options, next = null, { interRowLineBreaks = 1, leadingLineBreaks = 2, maxLineLength = undefined, maxPrefixLength = 0, prefixAlign = \"left\" } = {}){\n        super(options, next, leadingLineBreaks, maxLineLength);\n        this.maxPrefixLength = maxPrefixLength;\n        this.prefixAlign = prefixAlign;\n        this.interRowLineBreaks = interRowLineBreaks;\n    }\n}\nclass ListItemStackItem extends BlockStackItem {\n    constructor(options, next = null, { leadingLineBreaks = 1, maxLineLength = undefined, prefix = \"\" } = {}){\n        super(options, next, leadingLineBreaks, maxLineLength);\n        this.prefix = prefix;\n    }\n}\nclass TableStackItem extends StackItem {\n    constructor(next = null){\n        super(next);\n        this.rows = [];\n        this.isPre = next && next.isPre;\n        this.isNoWrap = next && next.isNoWrap;\n    }\n}\nclass TableRowStackItem extends StackItem {\n    constructor(next = null){\n        super(next);\n        this.cells = [];\n        this.isPre = next && next.isPre;\n        this.isNoWrap = next && next.isNoWrap;\n    }\n}\nclass TableCellStackItem extends StackItem {\n    constructor(options, next = null, maxColumnWidth = undefined){\n        super(next);\n        this.inlineTextBuilder = new InlineTextBuilder(options, maxColumnWidth);\n        this.rawText = \"\";\n        this.stashedLineBreaks = 0;\n        this.isPre = next && next.isPre;\n        this.isNoWrap = next && next.isNoWrap;\n    }\n}\nclass TransformerStackItem extends StackItem {\n    constructor(next = null, transform){\n        super(next);\n        this.transform = transform;\n    }\n}\nfunction charactersToCodes(str) {\n    return [\n        ...str\n    ].map((c)=>\"\\\\u\" + c.charCodeAt(0).toString(16).padStart(4, \"0\")).join(\"\");\n}\n/**\n * Helps to handle HTML whitespaces.\n *\n * @class WhitespaceProcessor\n */ class WhitespaceProcessor {\n    /**\n   * Creates an instance of WhitespaceProcessor.\n   *\n   * @param { Options } options    HtmlToText options.\n   * @memberof WhitespaceProcessor\n   */ constructor(options){\n        this.whitespaceChars = options.preserveNewlines ? options.whitespaceCharacters.replace(/\\n/g, \"\") : options.whitespaceCharacters;\n        const whitespaceCodes = charactersToCodes(this.whitespaceChars);\n        this.leadingWhitespaceRe = new RegExp(`^[${whitespaceCodes}]`);\n        this.trailingWhitespaceRe = new RegExp(`[${whitespaceCodes}]$`);\n        this.allWhitespaceOrEmptyRe = new RegExp(`^[${whitespaceCodes}]*$`);\n        this.newlineOrNonWhitespaceRe = new RegExp(`(\\\\n|[^\\\\n${whitespaceCodes}])`, \"g\");\n        this.newlineOrNonNewlineStringRe = new RegExp(`(\\\\n|[^\\\\n]+)`, \"g\");\n        if (options.preserveNewlines) {\n            const wordOrNewlineRe = new RegExp(`\\\\n|[^\\\\n${whitespaceCodes}]+`, \"gm\");\n            /**\n       * Shrink whitespaces and wrap text, add to the builder.\n       *\n       * @param { string }                  text              Input text.\n       * @param { InlineTextBuilder }       inlineTextBuilder A builder to receive processed text.\n       * @param { (str: string) => string } [ transform ]     A transform to be applied to words.\n       * @param { boolean }                 [noWrap] Don't wrap text even if the line is too long.\n       */ this.shrinkWrapAdd = function(text, inlineTextBuilder, transform = (str)=>str, noWrap = false) {\n                if (!text) {\n                    return;\n                }\n                const previouslyStashedSpace = inlineTextBuilder.stashedSpace;\n                let anyMatch = false;\n                let m = wordOrNewlineRe.exec(text);\n                if (m) {\n                    anyMatch = true;\n                    if (m[0] === \"\\n\") {\n                        inlineTextBuilder.startNewLine();\n                    } else if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {\n                        inlineTextBuilder.pushWord(transform(m[0]), noWrap);\n                    } else {\n                        inlineTextBuilder.concatWord(transform(m[0]), noWrap);\n                    }\n                    while((m = wordOrNewlineRe.exec(text)) !== null){\n                        if (m[0] === \"\\n\") {\n                            inlineTextBuilder.startNewLine();\n                        } else {\n                            inlineTextBuilder.pushWord(transform(m[0]), noWrap);\n                        }\n                    }\n                }\n                inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text);\n            // No need to stash a space in case last added item was a new line,\n            // but that won't affect anything later anyway.\n            };\n        } else {\n            const wordRe = new RegExp(`[^${whitespaceCodes}]+`, \"g\");\n            this.shrinkWrapAdd = function(text, inlineTextBuilder, transform = (str)=>str, noWrap = false) {\n                if (!text) {\n                    return;\n                }\n                const previouslyStashedSpace = inlineTextBuilder.stashedSpace;\n                let anyMatch = false;\n                let m = wordRe.exec(text);\n                if (m) {\n                    anyMatch = true;\n                    if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {\n                        inlineTextBuilder.pushWord(transform(m[0]), noWrap);\n                    } else {\n                        inlineTextBuilder.concatWord(transform(m[0]), noWrap);\n                    }\n                    while((m = wordRe.exec(text)) !== null){\n                        inlineTextBuilder.pushWord(transform(m[0]), noWrap);\n                    }\n                }\n                inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text);\n            };\n        }\n    }\n    /**\n   * Add text with only minimal processing.\n   * Everything between newlines considered a single word.\n   * No whitespace is trimmed.\n   * Not affected by preserveNewlines option - `\\n` always starts a new line.\n   *\n   * `noWrap` argument is `true` by default - this won't start a new line\n   * even if there is not enough space left in the current line.\n   *\n   * @param { string }            text              Input text.\n   * @param { InlineTextBuilder } inlineTextBuilder A builder to receive processed text.\n   * @param { boolean }           [noWrap] Don't wrap text even if the line is too long.\n   */ addLiteral(text, inlineTextBuilder, noWrap = true) {\n        if (!text) {\n            return;\n        }\n        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;\n        let anyMatch = false;\n        let m = this.newlineOrNonNewlineStringRe.exec(text);\n        if (m) {\n            anyMatch = true;\n            if (m[0] === \"\\n\") {\n                inlineTextBuilder.startNewLine();\n            } else if (previouslyStashedSpace) {\n                inlineTextBuilder.pushWord(m[0], noWrap);\n            } else {\n                inlineTextBuilder.concatWord(m[0], noWrap);\n            }\n            while((m = this.newlineOrNonNewlineStringRe.exec(text)) !== null){\n                if (m[0] === \"\\n\") {\n                    inlineTextBuilder.startNewLine();\n                } else {\n                    inlineTextBuilder.pushWord(m[0], noWrap);\n                }\n            }\n        }\n        inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch;\n    }\n    /**\n   * Test whether the given text starts with HTML whitespace character.\n   *\n   * @param   { string }  text  The string to test.\n   * @returns { boolean }\n   */ testLeadingWhitespace(text) {\n        return this.leadingWhitespaceRe.test(text);\n    }\n    /**\n   * Test whether the given text ends with HTML whitespace character.\n   *\n   * @param   { string }  text  The string to test.\n   * @returns { boolean }\n   */ testTrailingWhitespace(text) {\n        return this.trailingWhitespaceRe.test(text);\n    }\n    /**\n   * Test whether the given text contains any non-whitespace characters.\n   *\n   * @param   { string }  text  The string to test.\n   * @returns { boolean }\n   */ testContainsWords(text) {\n        return !this.allWhitespaceOrEmptyRe.test(text);\n    }\n    /**\n   * Return the number of newlines if there are no words.\n   *\n   * If any word is found then return zero regardless of the actual number of newlines.\n   *\n   * @param   { string }  text  Input string.\n   * @returns { number }\n   */ countNewlinesNoWords(text) {\n        this.newlineOrNonWhitespaceRe.lastIndex = 0;\n        let counter = 0;\n        let match;\n        while((match = this.newlineOrNonWhitespaceRe.exec(text)) !== null){\n            if (match[0] === \"\\n\") {\n                counter++;\n            } else {\n                return 0;\n            }\n        }\n        return counter;\n    }\n}\n/**\n * Helps to build text from inline and block elements.\n *\n * @class BlockTextBuilder\n */ class BlockTextBuilder {\n    /**\n   * Creates an instance of BlockTextBuilder.\n   *\n   * @param { Options } options HtmlToText options.\n   * @param { import('selderee').Picker<DomNode, TagDefinition> } picker Selectors decision tree picker.\n   * @param { any} [metadata] Optional metadata for HTML document, for use in formatters.\n   */ constructor(options, picker, metadata = undefined){\n        this.options = options;\n        this.picker = picker;\n        this.metadata = metadata;\n        this.whitespaceProcessor = new WhitespaceProcessor(options);\n        /** @type { StackItem } */ this._stackItem = new BlockStackItem(options);\n        /** @type { TransformerStackItem } */ this._wordTransformer = undefined;\n    }\n    /**\n   * Put a word-by-word transform function onto the transformations stack.\n   *\n   * Mainly used for uppercasing. Can be bypassed to add unformatted text such as URLs.\n   *\n   * Word transformations applied before wrapping.\n   *\n   * @param { (str: string) => string } wordTransform Word transformation function.\n   */ pushWordTransform(wordTransform) {\n        this._wordTransformer = new TransformerStackItem(this._wordTransformer, wordTransform);\n    }\n    /**\n   * Remove a function from the word transformations stack.\n   *\n   * @returns { (str: string) => string } A function that was removed.\n   */ popWordTransform() {\n        if (!this._wordTransformer) {\n            return undefined;\n        }\n        const transform = this._wordTransformer.transform;\n        this._wordTransformer = this._wordTransformer.next;\n        return transform;\n    }\n    /**\n   * Ignore wordwrap option in followup inline additions and disable automatic wrapping.\n   */ startNoWrap() {\n        this._stackItem.isNoWrap = true;\n    }\n    /**\n   * Return automatic wrapping to behavior defined by options.\n   */ stopNoWrap() {\n        this._stackItem.isNoWrap = false;\n    }\n    /** @returns { (str: string) => string } */ _getCombinedWordTransformer() {\n        const wt = this._wordTransformer ? (str)=>applyTransformer(str, this._wordTransformer) : undefined;\n        const ce = this.options.encodeCharacters;\n        return wt ? ce ? (str)=>ce(wt(str)) : wt : ce;\n    }\n    _popStackItem() {\n        const item = this._stackItem;\n        this._stackItem = item.next;\n        return item;\n    }\n    /**\n   * Add a line break into currently built block.\n   */ addLineBreak() {\n        if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {\n            return;\n        }\n        if (this._stackItem.isPre) {\n            this._stackItem.rawText += \"\\n\";\n        } else {\n            this._stackItem.inlineTextBuilder.startNewLine();\n        }\n    }\n    /**\n   * Allow to break line in case directly following text will not fit.\n   */ addWordBreakOpportunity() {\n        if (this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem) {\n            this._stackItem.inlineTextBuilder.wordBreakOpportunity = true;\n        }\n    }\n    /**\n   * Add a node inline into the currently built block.\n   *\n   * @param { string } str\n   * Text content of a node to add.\n   *\n   * @param { object } [param1]\n   * Object holding the parameters of the operation.\n   *\n   * @param { boolean } [param1.noWordTransform]\n   * Ignore word transformers if there are any.\n   * Don't encode characters as well.\n   * (Use this for things like URL addresses).\n   */ addInline(str, { noWordTransform = false } = {}) {\n        if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {\n            return;\n        }\n        if (this._stackItem.isPre) {\n            this._stackItem.rawText += str;\n            return;\n        }\n        if (str.length === 0 || // empty string\n        this._stackItem.stashedLineBreaks && // stashed linebreaks make whitespace irrelevant\n        !this.whitespaceProcessor.testContainsWords(str) // no words to add\n        ) {\n            return;\n        }\n        if (this.options.preserveNewlines) {\n            const newlinesNumber = this.whitespaceProcessor.countNewlinesNoWords(str);\n            if (newlinesNumber > 0) {\n                this._stackItem.inlineTextBuilder.startNewLine(newlinesNumber);\n                // keep stashedLineBreaks unchanged\n                return;\n            }\n        }\n        if (this._stackItem.stashedLineBreaks) {\n            this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);\n        }\n        this.whitespaceProcessor.shrinkWrapAdd(str, this._stackItem.inlineTextBuilder, noWordTransform ? undefined : this._getCombinedWordTransformer(), this._stackItem.isNoWrap);\n        this._stackItem.stashedLineBreaks = 0; // inline text doesn't introduce line breaks\n    }\n    /**\n   * Add a string inline into the currently built block.\n   *\n   * Use this for markup elements that don't have to adhere\n   * to text layout rules.\n   *\n   * @param { string } str Text to add.\n   */ addLiteral(str) {\n        if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {\n            return;\n        }\n        if (str.length === 0) {\n            return;\n        }\n        if (this._stackItem.isPre) {\n            this._stackItem.rawText += str;\n            return;\n        }\n        if (this._stackItem.stashedLineBreaks) {\n            this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);\n        }\n        this.whitespaceProcessor.addLiteral(str, this._stackItem.inlineTextBuilder, this._stackItem.isNoWrap);\n        this._stackItem.stashedLineBreaks = 0;\n    }\n    /**\n   * Start building a new block.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the block.\n   *\n   * @param { number } [param0.leadingLineBreaks]\n   * This block should have at least this number of line breaks to separate it from any preceding block.\n   *\n   * @param { number }  [param0.reservedLineLength]\n   * Reserve this number of characters on each line for block markup.\n   *\n   * @param { boolean } [param0.isPre]\n   * Should HTML whitespace be preserved inside this block.\n   */ openBlock({ leadingLineBreaks = 1, reservedLineLength = 0, isPre = false } = {}) {\n        const maxLineLength = Math.max(20, this._stackItem.inlineTextBuilder.maxLineLength - reservedLineLength);\n        this._stackItem = new BlockStackItem(this.options, this._stackItem, leadingLineBreaks, maxLineLength);\n        if (isPre) {\n            this._stackItem.isPre = true;\n        }\n    }\n    /**\n   * Finalize currently built block, add it's content to the parent block.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the block.\n   *\n   * @param { number } [param0.trailingLineBreaks]\n   * This block should have at least this number of line breaks to separate it from any following block.\n   *\n   * @param { (str: string) => string } [param0.blockTransform]\n   * A function to transform the block text before adding to the parent block.\n   * This happens after word wrap and should be used in combination with reserved line length\n   * in order to keep line lengths correct.\n   * Used for whole block markup.\n   */ closeBlock({ trailingLineBreaks = 1, blockTransform = undefined } = {}) {\n        const block = this._popStackItem();\n        const blockText = blockTransform ? blockTransform(getText(block)) : getText(block);\n        addText(this._stackItem, blockText, block.leadingLineBreaks, Math.max(block.stashedLineBreaks, trailingLineBreaks));\n    }\n    /**\n   * Start building a new list.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the list.\n   *\n   * @param { number } [param0.maxPrefixLength]\n   * Length of the longest list item prefix.\n   * If not supplied or too small then list items won't be aligned properly.\n   *\n   * @param { 'left' | 'right' } [param0.prefixAlign]\n   * Specify how prefixes of different lengths have to be aligned\n   * within a column.\n   *\n   * @param { number } [param0.interRowLineBreaks]\n   * Minimum number of line breaks between list items.\n   *\n   * @param { number } [param0.leadingLineBreaks]\n   * This list should have at least this number of line breaks to separate it from any preceding block.\n   */ openList({ maxPrefixLength = 0, prefixAlign = \"left\", interRowLineBreaks = 1, leadingLineBreaks = 2 } = {}) {\n        this._stackItem = new ListStackItem(this.options, this._stackItem, {\n            interRowLineBreaks: interRowLineBreaks,\n            leadingLineBreaks: leadingLineBreaks,\n            maxLineLength: this._stackItem.inlineTextBuilder.maxLineLength,\n            maxPrefixLength: maxPrefixLength,\n            prefixAlign: prefixAlign\n        });\n    }\n    /**\n   * Start building a new list item.\n   *\n   * @param {object} param0\n   * Object holding the parameters of the list item.\n   *\n   * @param { string } [param0.prefix]\n   * Prefix for this list item (item number, bullet point, etc).\n   */ openListItem({ prefix = \"\" } = {}) {\n        if (!(this._stackItem instanceof ListStackItem)) {\n            throw new Error(\"Can't add a list item to something that is not a list! Check the formatter.\");\n        }\n        const list = this._stackItem;\n        const prefixLength = Math.max(prefix.length, list.maxPrefixLength);\n        const maxLineLength = Math.max(20, list.inlineTextBuilder.maxLineLength - prefixLength);\n        this._stackItem = new ListItemStackItem(this.options, list, {\n            prefix: prefix,\n            maxLineLength: maxLineLength,\n            leadingLineBreaks: list.interRowLineBreaks\n        });\n    }\n    /**\n   * Finalize currently built list item, add it's content to the parent list.\n   */ closeListItem() {\n        const listItem = this._popStackItem();\n        const list = listItem.next;\n        const prefixLength = Math.max(listItem.prefix.length, list.maxPrefixLength);\n        const spacing = \"\\n\" + \" \".repeat(prefixLength);\n        const prefix = list.prefixAlign === \"right\" ? listItem.prefix.padStart(prefixLength) : listItem.prefix.padEnd(prefixLength);\n        const text = prefix + getText(listItem).replace(/\\n/g, spacing);\n        addText(list, text, listItem.leadingLineBreaks, Math.max(listItem.stashedLineBreaks, list.interRowLineBreaks));\n    }\n    /**\n   * Finalize currently built list, add it's content to the parent block.\n   *\n   * @param { object } param0\n   * Object holding the parameters of the list.\n   *\n   * @param { number } [param0.trailingLineBreaks]\n   * This list should have at least this number of line breaks to separate it from any following block.\n   */ closeList({ trailingLineBreaks = 2 } = {}) {\n        const list = this._popStackItem();\n        const text = getText(list);\n        if (text) {\n            addText(this._stackItem, text, list.leadingLineBreaks, trailingLineBreaks);\n        }\n    }\n    /**\n   * Start building a table.\n   */ openTable() {\n        this._stackItem = new TableStackItem(this._stackItem);\n    }\n    /**\n   * Start building a table row.\n   */ openTableRow() {\n        if (!(this._stackItem instanceof TableStackItem)) {\n            throw new Error(\"Can't add a table row to something that is not a table! Check the formatter.\");\n        }\n        this._stackItem = new TableRowStackItem(this._stackItem);\n    }\n    /**\n   * Start building a table cell.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the cell.\n   *\n   * @param { number } [param0.maxColumnWidth]\n   * Wrap cell content to this width. Fall back to global wordwrap value if undefined.\n   */ openTableCell({ maxColumnWidth = undefined } = {}) {\n        if (!(this._stackItem instanceof TableRowStackItem)) {\n            throw new Error(\"Can't add a table cell to something that is not a table row! Check the formatter.\");\n        }\n        this._stackItem = new TableCellStackItem(this.options, this._stackItem, maxColumnWidth);\n    }\n    /**\n   * Finalize currently built table cell and add it to parent table row's cells.\n   *\n   * @param { object } [param0]\n   * Object holding the parameters of the cell.\n   *\n   * @param { number } [param0.colspan] How many columns this cell should occupy.\n   * @param { number } [param0.rowspan] How many rows this cell should occupy.\n   */ closeTableCell({ colspan = 1, rowspan = 1 } = {}) {\n        const cell = this._popStackItem();\n        const text = trimCharacter(getText(cell), \"\\n\");\n        cell.next.cells.push({\n            colspan: colspan,\n            rowspan: rowspan,\n            text: text\n        });\n    }\n    /**\n   * Finalize currently built table row and add it to parent table's rows.\n   */ closeTableRow() {\n        const row = this._popStackItem();\n        row.next.rows.push(row.cells);\n    }\n    /**\n   * Finalize currently built table and add the rendered text to the parent block.\n   *\n   * @param { object } param0\n   * Object holding the parameters of the table.\n   *\n   * @param { TablePrinter } param0.tableToString\n   * A function to convert a table of stringified cells into a complete table.\n   *\n   * @param { number } [param0.leadingLineBreaks]\n   * This table should have at least this number of line breaks to separate if from any preceding block.\n   *\n   * @param { number } [param0.trailingLineBreaks]\n   * This table should have at least this number of line breaks to separate it from any following block.\n   */ closeTable({ tableToString, leadingLineBreaks = 2, trailingLineBreaks = 2 }) {\n        const table = this._popStackItem();\n        const output = tableToString(table.rows);\n        if (output) {\n            addText(this._stackItem, output, leadingLineBreaks, trailingLineBreaks);\n        }\n    }\n    /**\n   * Return the rendered text content of this builder.\n   *\n   * @returns { string }\n   */ toString() {\n        return getText(this._stackItem.getRoot());\n    // There should only be the root item if everything is closed properly.\n    }\n}\nfunction getText(stackItem) {\n    if (!(stackItem instanceof BlockStackItem || stackItem instanceof ListItemStackItem || stackItem instanceof TableCellStackItem)) {\n        throw new Error(\"Only blocks, list items and table cells can be requested for text contents.\");\n    }\n    return stackItem.inlineTextBuilder.isEmpty() ? stackItem.rawText : stackItem.rawText + stackItem.inlineTextBuilder.toString();\n}\nfunction addText(stackItem, text, leadingLineBreaks, trailingLineBreaks) {\n    if (!(stackItem instanceof BlockStackItem || stackItem instanceof ListItemStackItem || stackItem instanceof TableCellStackItem)) {\n        throw new Error(\"Only blocks, list items and table cells can contain text.\");\n    }\n    const parentText = getText(stackItem);\n    const lineBreaks = Math.max(stackItem.stashedLineBreaks, leadingLineBreaks);\n    stackItem.inlineTextBuilder.clear();\n    if (parentText) {\n        stackItem.rawText = parentText + \"\\n\".repeat(lineBreaks) + text;\n    } else {\n        stackItem.rawText = text;\n        stackItem.leadingLineBreaks = lineBreaks;\n    }\n    stackItem.stashedLineBreaks = trailingLineBreaks;\n}\n/**\n * @param { string } str A string to transform.\n * @param { TransformerStackItem } transformer A transformer item (with possible continuation).\n * @returns { string }\n */ function applyTransformer(str, transformer) {\n    return transformer ? applyTransformer(transformer.transform(str), transformer.next) : str;\n}\n/**\n * Compile selectors into a decision tree,\n * return a function intended for batch processing.\n *\n * @param   { Options } [options = {}]   HtmlToText options (defaults, formatters, user options merged, deduplicated).\n * @returns { (html: string, metadata?: any) => string } Pre-configured converter function.\n * @static\n */ function compile$1(options = {}) {\n    const selectorsWithoutFormat = options.selectors.filter((s)=>!s.format);\n    if (selectorsWithoutFormat.length) {\n        throw new Error(\"Following selectors have no specified format: \" + selectorsWithoutFormat.map((s)=>`\\`${s.selector}\\``).join(\", \"));\n    }\n    const picker = new selderee.DecisionTree(options.selectors.map((s)=>[\n            s.selector,\n            s\n        ])).build(pluginHtmlparser2.hp2Builder);\n    if (typeof options.encodeCharacters !== \"function\") {\n        options.encodeCharacters = makeReplacerFromDict(options.encodeCharacters);\n    }\n    const baseSelectorsPicker = new selderee.DecisionTree(options.baseElements.selectors.map((s, i)=>[\n            s,\n            i + 1\n        ])).build(pluginHtmlparser2.hp2Builder);\n    function findBaseElements(dom) {\n        return findBases(dom, options, baseSelectorsPicker);\n    }\n    const limitedWalk = limitedDepthRecursive(options.limits.maxDepth, recursiveWalk, function(dom, builder) {\n        builder.addInline(options.limits.ellipsis || \"\");\n    });\n    return function(html, metadata = undefined) {\n        return process(html, metadata, options, picker, findBaseElements, limitedWalk);\n    };\n}\n/**\n * Convert given HTML according to preprocessed options.\n *\n * @param { string } html HTML content to convert.\n * @param { any } metadata Optional metadata for HTML document, for use in formatters.\n * @param { Options } options HtmlToText options (preprocessed).\n * @param { import('selderee').Picker<DomNode, TagDefinition> } picker\n * Tag definition picker for DOM nodes processing.\n * @param { (dom: DomNode[]) => DomNode[] } findBaseElements\n * Function to extract elements from HTML DOM\n * that will only be present in the output text.\n * @param { RecursiveCallback } walk Recursive callback.\n * @returns { string }\n */ function process(html, metadata, options, picker, findBaseElements, walk) {\n    const maxInputLength = options.limits.maxInputLength;\n    if (maxInputLength && html && html.length > maxInputLength) {\n        console.warn(`Input length ${html.length} is above allowed limit of ${maxInputLength}. Truncating without ellipsis.`);\n        html = html.substring(0, maxInputLength);\n    }\n    const document = htmlparser2.parseDocument(html, {\n        decodeEntities: options.decodeEntities\n    });\n    const bases = findBaseElements(document.children);\n    const builder = new BlockTextBuilder(options, picker, metadata);\n    walk(bases, builder);\n    return builder.toString();\n}\nfunction findBases(dom, options, baseSelectorsPicker) {\n    const results = [];\n    function recursiveWalk(walk, /** @type { DomNode[] } */ dom) {\n        dom = dom.slice(0, options.limits.maxChildNodes);\n        for (const elem of dom){\n            if (elem.type !== \"tag\") {\n                continue;\n            }\n            const pickedSelectorIndex = baseSelectorsPicker.pick1(elem);\n            if (pickedSelectorIndex > 0) {\n                results.push({\n                    selectorIndex: pickedSelectorIndex,\n                    element: elem\n                });\n            } else if (elem.children) {\n                walk(elem.children);\n            }\n            if (results.length >= options.limits.maxBaseElements) {\n                return;\n            }\n        }\n    }\n    const limitedWalk = limitedDepthRecursive(options.limits.maxDepth, recursiveWalk);\n    limitedWalk(dom);\n    if (options.baseElements.orderBy !== \"occurrence\") {\n        results.sort((a, b)=>a.selectorIndex - b.selectorIndex);\n    }\n    return options.baseElements.returnDomByDefault && results.length === 0 ? dom : results.map((x)=>x.element);\n}\n/**\n * Function to walk through DOM nodes and accumulate their string representations.\n *\n * @param   { RecursiveCallback } walk    Recursive callback.\n * @param   { DomNode[] }         [dom]   Nodes array to process.\n * @param   { BlockTextBuilder }  builder Passed around to accumulate output text.\n * @private\n */ function recursiveWalk(walk, dom, builder) {\n    if (!dom) {\n        return;\n    }\n    const options = builder.options;\n    const tooManyChildNodes = dom.length > options.limits.maxChildNodes;\n    if (tooManyChildNodes) {\n        dom = dom.slice(0, options.limits.maxChildNodes);\n        dom.push({\n            data: options.limits.ellipsis,\n            type: \"text\"\n        });\n    }\n    for (const elem of dom){\n        switch(elem.type){\n            case \"text\":\n                {\n                    builder.addInline(elem.data);\n                    break;\n                }\n            case \"tag\":\n                {\n                    const tagDefinition = builder.picker.pick1(elem);\n                    const format = options.formatters[tagDefinition.format];\n                    format(elem, walk, builder, tagDefinition.options || {});\n                    break;\n                }\n        }\n    }\n    return;\n}\n/**\n * @param { Object<string,string | false> } dict\n * A dictionary where keys are characters to replace\n * and values are replacement strings.\n *\n * First code point from dict keys is used.\n * Compound emojis with ZWJ are not supported (not until Node 16).\n *\n * @returns { ((str: string) => string) | undefined }\n */ function makeReplacerFromDict(dict) {\n    if (!dict || Object.keys(dict).length === 0) {\n        return undefined;\n    }\n    /** @type { [string, string][] } */ const entries = Object.entries(dict).filter(([, v])=>v !== false);\n    const regex = new RegExp(entries.map(([c])=>`(${unicodeEscape([\n            ...c\n        ][0])})`).join(\"|\"), \"g\");\n    const values = entries.map(([, v])=>v);\n    const replacer = (m, ...cgs)=>values[cgs.findIndex((cg)=>cg)];\n    return (str)=>str.replace(regex, replacer);\n}\n/**\n * Dummy formatter that discards the input and does nothing.\n *\n * @type { FormatCallback }\n */ function formatSkip(elem, walk, builder, formatOptions) {\n/* do nothing */ }\n/**\n * Insert the given string literal inline instead of a tag.\n *\n * @type { FormatCallback }\n */ function formatInlineString(elem, walk, builder, formatOptions) {\n    builder.addLiteral(formatOptions.string || \"\");\n}\n/**\n * Insert a block with the given string literal instead of a tag.\n *\n * @type { FormatCallback }\n */ function formatBlockString(elem, walk, builder, formatOptions) {\n    builder.openBlock({\n        leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n    });\n    builder.addLiteral(formatOptions.string || \"\");\n    builder.closeBlock({\n        trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n    });\n}\n/**\n * Process an inline-level element.\n *\n * @type { FormatCallback }\n */ function formatInline(elem, walk, builder, formatOptions) {\n    walk(elem.children, builder);\n}\n/**\n * Process a block-level container.\n *\n * @type { FormatCallback }\n */ function formatBlock$1(elem, walk, builder, formatOptions) {\n    builder.openBlock({\n        leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n    });\n    walk(elem.children, builder);\n    builder.closeBlock({\n        trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n    });\n}\nfunction renderOpenTag(elem) {\n    const attrs = elem.attribs && elem.attribs.length ? \" \" + Object.entries(elem.attribs).map(([k, v])=>v === \"\" ? k : `${k}=${v.replace(/\"/g, \"&quot;\")}`).join(\" \") : \"\";\n    return `<${elem.name}${attrs}>`;\n}\nfunction renderCloseTag(elem) {\n    return `</${elem.name}>`;\n}\n/**\n * Render an element as inline HTML tag, walk through it's children.\n *\n * @type { FormatCallback }\n */ function formatInlineTag(elem, walk, builder, formatOptions) {\n    builder.startNoWrap();\n    builder.addLiteral(renderOpenTag(elem));\n    builder.stopNoWrap();\n    walk(elem.children, builder);\n    builder.startNoWrap();\n    builder.addLiteral(renderCloseTag(elem));\n    builder.stopNoWrap();\n}\n/**\n * Render an element as HTML block bag, walk through it's children.\n *\n * @type { FormatCallback }\n */ function formatBlockTag(elem, walk, builder, formatOptions) {\n    builder.openBlock({\n        leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n    });\n    builder.startNoWrap();\n    builder.addLiteral(renderOpenTag(elem));\n    builder.stopNoWrap();\n    walk(elem.children, builder);\n    builder.startNoWrap();\n    builder.addLiteral(renderCloseTag(elem));\n    builder.stopNoWrap();\n    builder.closeBlock({\n        trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n    });\n}\n/**\n * Render an element with all it's children as inline HTML.\n *\n * @type { FormatCallback }\n */ function formatInlineHtml(elem, walk, builder, formatOptions) {\n    builder.startNoWrap();\n    builder.addLiteral(domSerializer.render(elem, {\n        decodeEntities: builder.options.decodeEntities\n    }));\n    builder.stopNoWrap();\n}\n/**\n * Render an element with all it's children as HTML block.\n *\n * @type { FormatCallback }\n */ function formatBlockHtml(elem, walk, builder, formatOptions) {\n    builder.openBlock({\n        leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n    });\n    builder.startNoWrap();\n    builder.addLiteral(domSerializer.render(elem, {\n        decodeEntities: builder.options.decodeEntities\n    }));\n    builder.stopNoWrap();\n    builder.closeBlock({\n        trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n    });\n}\n/**\n * Render inline element wrapped with given strings.\n *\n * @type { FormatCallback }\n */ function formatInlineSurround(elem, walk, builder, formatOptions) {\n    builder.addLiteral(formatOptions.prefix || \"\");\n    walk(elem.children, builder);\n    builder.addLiteral(formatOptions.suffix || \"\");\n}\nvar genericFormatters = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    block: formatBlock$1,\n    blockHtml: formatBlockHtml,\n    blockString: formatBlockString,\n    blockTag: formatBlockTag,\n    inline: formatInline,\n    inlineHtml: formatInlineHtml,\n    inlineString: formatInlineString,\n    inlineSurround: formatInlineSurround,\n    inlineTag: formatInlineTag,\n    skip: formatSkip\n});\nfunction getRow(matrix, j) {\n    if (!matrix[j]) {\n        matrix[j] = [];\n    }\n    return matrix[j];\n}\nfunction findFirstVacantIndex(row, x = 0) {\n    while(row[x]){\n        x++;\n    }\n    return x;\n}\nfunction transposeInPlace(matrix, maxSize) {\n    for(let i = 0; i < maxSize; i++){\n        const rowI = getRow(matrix, i);\n        for(let j = 0; j < i; j++){\n            const rowJ = getRow(matrix, j);\n            if (rowI[j] || rowJ[i]) {\n                const temp = rowI[j];\n                rowI[j] = rowJ[i];\n                rowJ[i] = temp;\n            }\n        }\n    }\n}\nfunction putCellIntoLayout(cell, layout, baseRow, baseCol) {\n    for(let r = 0; r < cell.rowspan; r++){\n        const layoutRow = getRow(layout, baseRow + r);\n        for(let c = 0; c < cell.colspan; c++){\n            layoutRow[baseCol + c] = cell;\n        }\n    }\n}\nfunction getOrInitOffset(offsets, index) {\n    if (offsets[index] === undefined) {\n        offsets[index] = index === 0 ? 0 : 1 + getOrInitOffset(offsets, index - 1);\n    }\n    return offsets[index];\n}\nfunction updateOffset(offsets, base, span, value) {\n    offsets[base + span] = Math.max(getOrInitOffset(offsets, base + span), getOrInitOffset(offsets, base) + value);\n}\n/**\n * Render a table into a string.\n * Cells can contain multiline text and span across multiple rows and columns.\n *\n * Modifies cells to add lines array.\n *\n * @param { TablePrinterCell[][] } tableRows Table to render.\n * @param { number } rowSpacing Number of spaces between columns.\n * @param { number } colSpacing Number of empty lines between rows.\n * @returns { string }\n */ function tableToString(tableRows, rowSpacing, colSpacing) {\n    const layout = [];\n    let colNumber = 0;\n    const rowNumber = tableRows.length;\n    const rowOffsets = [\n        0\n    ];\n    // Fill the layout table and row offsets row-by-row.\n    for(let j = 0; j < rowNumber; j++){\n        const layoutRow = getRow(layout, j);\n        const cells = tableRows[j];\n        let x = 0;\n        for(let i = 0; i < cells.length; i++){\n            const cell = cells[i];\n            x = findFirstVacantIndex(layoutRow, x);\n            putCellIntoLayout(cell, layout, j, x);\n            x += cell.colspan;\n            cell.lines = cell.text.split(\"\\n\");\n            const cellHeight = cell.lines.length;\n            updateOffset(rowOffsets, j, cell.rowspan, cellHeight + rowSpacing);\n        }\n        colNumber = layoutRow.length > colNumber ? layoutRow.length : colNumber;\n    }\n    transposeInPlace(layout, rowNumber > colNumber ? rowNumber : colNumber);\n    const outputLines = [];\n    const colOffsets = [\n        0\n    ];\n    // Fill column offsets and output lines column-by-column.\n    for(let x = 0; x < colNumber; x++){\n        let y = 0;\n        let cell;\n        const rowsInThisColumn = Math.min(rowNumber, layout[x].length);\n        while(y < rowsInThisColumn){\n            cell = layout[x][y];\n            if (cell) {\n                if (!cell.rendered) {\n                    let cellWidth = 0;\n                    for(let j = 0; j < cell.lines.length; j++){\n                        const line = cell.lines[j];\n                        const lineOffset = rowOffsets[y] + j;\n                        outputLines[lineOffset] = (outputLines[lineOffset] || \"\").padEnd(colOffsets[x]) + line;\n                        cellWidth = line.length > cellWidth ? line.length : cellWidth;\n                    }\n                    updateOffset(colOffsets, x, cell.colspan, cellWidth + colSpacing);\n                    cell.rendered = true;\n                }\n                y += cell.rowspan;\n            } else {\n                const lineOffset = rowOffsets[y];\n                outputLines[lineOffset] = outputLines[lineOffset] || \"\";\n                y++;\n            }\n        }\n    }\n    return outputLines.join(\"\\n\");\n}\n/**\n * Process a line-break.\n *\n * @type { FormatCallback }\n */ function formatLineBreak(elem, walk, builder, formatOptions) {\n    builder.addLineBreak();\n}\n/**\n * Process a `wbr` tag (word break opportunity).\n *\n * @type { FormatCallback }\n */ function formatWbr(elem, walk, builder, formatOptions) {\n    builder.addWordBreakOpportunity();\n}\n/**\n * Process a horizontal line.\n *\n * @type { FormatCallback }\n */ function formatHorizontalLine(elem, walk, builder, formatOptions) {\n    builder.openBlock({\n        leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n    });\n    builder.addInline(\"-\".repeat(formatOptions.length || builder.options.wordwrap || 40));\n    builder.closeBlock({\n        trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n    });\n}\n/**\n * Process a paragraph.\n *\n * @type { FormatCallback }\n */ function formatParagraph(elem, walk, builder, formatOptions) {\n    builder.openBlock({\n        leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n    });\n    walk(elem.children, builder);\n    builder.closeBlock({\n        trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n    });\n}\n/**\n * Process a preformatted content.\n *\n * @type { FormatCallback }\n */ function formatPre(elem, walk, builder, formatOptions) {\n    builder.openBlock({\n        isPre: true,\n        leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n    });\n    walk(elem.children, builder);\n    builder.closeBlock({\n        trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n    });\n}\n/**\n * Process a heading.\n *\n * @type { FormatCallback }\n */ function formatHeading(elem, walk, builder, formatOptions) {\n    builder.openBlock({\n        leadingLineBreaks: formatOptions.leadingLineBreaks || 2\n    });\n    if (formatOptions.uppercase !== false) {\n        builder.pushWordTransform((str)=>str.toUpperCase());\n        walk(elem.children, builder);\n        builder.popWordTransform();\n    } else {\n        walk(elem.children, builder);\n    }\n    builder.closeBlock({\n        trailingLineBreaks: formatOptions.trailingLineBreaks || 2\n    });\n}\n/**\n * Process a blockquote.\n *\n * @type { FormatCallback }\n */ function formatBlockquote(elem, walk, builder, formatOptions) {\n    builder.openBlock({\n        leadingLineBreaks: formatOptions.leadingLineBreaks || 2,\n        reservedLineLength: 2\n    });\n    walk(elem.children, builder);\n    builder.closeBlock({\n        trailingLineBreaks: formatOptions.trailingLineBreaks || 2,\n        blockTransform: (str)=>(formatOptions.trimEmptyLines !== false ? trimCharacter(str, \"\\n\") : str).split(\"\\n\").map((line)=>\"> \" + line).join(\"\\n\")\n    });\n}\nfunction withBrackets(str, brackets) {\n    if (!brackets) {\n        return str;\n    }\n    const lbr = typeof brackets[0] === \"string\" ? brackets[0] : \"[\";\n    const rbr = typeof brackets[1] === \"string\" ? brackets[1] : \"]\";\n    return lbr + str + rbr;\n}\nfunction pathRewrite(path, rewriter, baseUrl, metadata, elem) {\n    const modifiedPath = typeof rewriter === \"function\" ? rewriter(path, metadata, elem) : path;\n    return modifiedPath[0] === \"/\" && baseUrl ? trimCharacterEnd(baseUrl, \"/\") + modifiedPath : modifiedPath;\n}\n/**\n * Process an image.\n *\n * @type { FormatCallback }\n */ function formatImage(elem, walk, builder, formatOptions) {\n    const attribs = elem.attribs || {};\n    const alt = attribs.alt ? attribs.alt : \"\";\n    const src = !attribs.src ? \"\" : pathRewrite(attribs.src, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);\n    const text = !src ? alt : !alt ? withBrackets(src, formatOptions.linkBrackets) : alt + \" \" + withBrackets(src, formatOptions.linkBrackets);\n    builder.addInline(text, {\n        noWordTransform: true\n    });\n}\n// a img baseUrl\n// a img pathRewrite\n// a img linkBrackets\n// a     ignoreHref: false\n//            ignoreText ?\n// a     noAnchorUrl: true\n//            can be replaced with selector\n// a     hideLinkHrefIfSameAsText: false\n//            how to compare, what to show (text, href, normalized) ?\n// a     mailto protocol removed without options\n// a     protocols: mailto, tel, ...\n//            can be matched with selector?\n// anchors, protocols - only if no pathRewrite fn is provided\n// normalize-url ?\n// a\n// a[href^=\"#\"] - format:skip by default\n// a[href^=\"mailto:\"] - ?\n/**\n * Process an anchor.\n *\n * @type { FormatCallback }\n */ function formatAnchor(elem, walk, builder, formatOptions) {\n    function getHref() {\n        if (formatOptions.ignoreHref) {\n            return \"\";\n        }\n        if (!elem.attribs || !elem.attribs.href) {\n            return \"\";\n        }\n        let href = elem.attribs.href.replace(/^mailto:/, \"\");\n        if (formatOptions.noAnchorUrl && href[0] === \"#\") {\n            return \"\";\n        }\n        href = pathRewrite(href, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);\n        return href;\n    }\n    const href = getHref();\n    if (!href) {\n        walk(elem.children, builder);\n    } else {\n        let text = \"\";\n        builder.pushWordTransform((str)=>{\n            if (str) {\n                text += str;\n            }\n            return str;\n        });\n        walk(elem.children, builder);\n        builder.popWordTransform();\n        const hideSameLink = formatOptions.hideLinkHrefIfSameAsText && href === text;\n        if (!hideSameLink) {\n            builder.addInline(!text ? href : \" \" + withBrackets(href, formatOptions.linkBrackets), {\n                noWordTransform: true\n            });\n        }\n    }\n}\n/**\n * @param { DomNode }           elem               List items with their prefixes.\n * @param { RecursiveCallback } walk               Recursive callback to process child nodes.\n * @param { BlockTextBuilder }  builder            Passed around to accumulate output text.\n * @param { FormatOptions }     formatOptions      Options specific to a formatter.\n * @param { () => string }      nextPrefixCallback Function that returns increasing index each time it is called.\n */ function formatList(elem, walk, builder, formatOptions, nextPrefixCallback) {\n    const isNestedList = get(elem, [\n        \"parent\",\n        \"name\"\n    ]) === \"li\";\n    // With Roman numbers, index length is not as straightforward as with Arabic numbers or letters,\n    // so the dumb length comparison is the most robust way to get the correct value.\n    let maxPrefixLength = 0;\n    const listItems = (elem.children || [])// it might be more accurate to check only for html spaces here, but no significant benefit\n    .filter((child)=>child.type !== \"text\" || !/^\\s*$/.test(child.data)).map(function(child) {\n        if (child.name !== \"li\") {\n            return {\n                node: child,\n                prefix: \"\"\n            };\n        }\n        const prefix = isNestedList ? nextPrefixCallback().trimStart() : nextPrefixCallback();\n        if (prefix.length > maxPrefixLength) {\n            maxPrefixLength = prefix.length;\n        }\n        return {\n            node: child,\n            prefix: prefix\n        };\n    });\n    if (!listItems.length) {\n        return;\n    }\n    builder.openList({\n        interRowLineBreaks: 1,\n        leadingLineBreaks: isNestedList ? 1 : formatOptions.leadingLineBreaks || 2,\n        maxPrefixLength: maxPrefixLength,\n        prefixAlign: \"left\"\n    });\n    for (const { node, prefix } of listItems){\n        builder.openListItem({\n            prefix: prefix\n        });\n        walk([\n            node\n        ], builder);\n        builder.closeListItem();\n    }\n    builder.closeList({\n        trailingLineBreaks: isNestedList ? 1 : formatOptions.trailingLineBreaks || 2\n    });\n}\n/**\n * Process an unordered list.\n *\n * @type { FormatCallback }\n */ function formatUnorderedList(elem, walk, builder, formatOptions) {\n    const prefix = formatOptions.itemPrefix || \" * \";\n    return formatList(elem, walk, builder, formatOptions, ()=>prefix);\n}\n/**\n * Process an ordered list.\n *\n * @type { FormatCallback }\n */ function formatOrderedList(elem, walk, builder, formatOptions) {\n    let nextIndex = Number(elem.attribs.start || \"1\");\n    const indexFunction = getOrderedListIndexFunction(elem.attribs.type);\n    const nextPrefixCallback = ()=>\" \" + indexFunction(nextIndex++) + \". \";\n    return formatList(elem, walk, builder, formatOptions, nextPrefixCallback);\n}\n/**\n * Return a function that can be used to generate index markers of a specified format.\n *\n * @param   { string } [olType='1'] Marker type.\n * @returns { (i: number) => string }\n */ function getOrderedListIndexFunction(olType = \"1\") {\n    switch(olType){\n        case \"a\":\n            return (i)=>numberToLetterSequence(i, \"a\");\n        case \"A\":\n            return (i)=>numberToLetterSequence(i, \"A\");\n        case \"i\":\n            return (i)=>numberToRoman(i).toLowerCase();\n        case \"I\":\n            return (i)=>numberToRoman(i);\n        case \"1\":\n        default:\n            return (i)=>i.toString();\n    }\n}\n/**\n * Given a list of class and ID selectors (prefixed with '.' and '#'),\n * return them as separate lists of names without prefixes.\n *\n * @param { string[] } selectors Class and ID selectors (`[\".class\", \"#id\"]` etc).\n * @returns { { classes: string[], ids: string[] } }\n */ function splitClassesAndIds(selectors) {\n    const classes = [];\n    const ids = [];\n    for (const selector of selectors){\n        if (selector.startsWith(\".\")) {\n            classes.push(selector.substring(1));\n        } else if (selector.startsWith(\"#\")) {\n            ids.push(selector.substring(1));\n        }\n    }\n    return {\n        classes: classes,\n        ids: ids\n    };\n}\nfunction isDataTable(attr, tables) {\n    if (tables === true) {\n        return true;\n    }\n    if (!attr) {\n        return false;\n    }\n    const { classes, ids } = splitClassesAndIds(tables);\n    const attrClasses = (attr[\"class\"] || \"\").split(\" \");\n    const attrIds = (attr[\"id\"] || \"\").split(\" \");\n    return attrClasses.some((x)=>classes.includes(x)) || attrIds.some((x)=>ids.includes(x));\n}\n/**\n * Process a table (either as a container or as a data table, depending on options).\n *\n * @type { FormatCallback }\n */ function formatTable(elem, walk, builder, formatOptions) {\n    return isDataTable(elem.attribs, builder.options.tables) ? formatDataTable(elem, walk, builder, formatOptions) : formatBlock(elem, walk, builder, formatOptions);\n}\nfunction formatBlock(elem, walk, builder, formatOptions) {\n    builder.openBlock({\n        leadingLineBreaks: formatOptions.leadingLineBreaks\n    });\n    walk(elem.children, builder);\n    builder.closeBlock({\n        trailingLineBreaks: formatOptions.trailingLineBreaks\n    });\n}\n/**\n * Process a data table.\n *\n * @type { FormatCallback }\n */ function formatDataTable(elem, walk, builder, formatOptions) {\n    builder.openTable();\n    elem.children.forEach(walkTable);\n    builder.closeTable({\n        tableToString: (rows)=>tableToString(rows, formatOptions.rowSpacing ?? 0, formatOptions.colSpacing ?? 3),\n        leadingLineBreaks: formatOptions.leadingLineBreaks,\n        trailingLineBreaks: formatOptions.trailingLineBreaks\n    });\n    function formatCell(cellNode) {\n        const colspan = +get(cellNode, [\n            \"attribs\",\n            \"colspan\"\n        ]) || 1;\n        const rowspan = +get(cellNode, [\n            \"attribs\",\n            \"rowspan\"\n        ]) || 1;\n        builder.openTableCell({\n            maxColumnWidth: formatOptions.maxColumnWidth\n        });\n        walk(cellNode.children, builder);\n        builder.closeTableCell({\n            colspan: colspan,\n            rowspan: rowspan\n        });\n    }\n    function walkTable(elem) {\n        if (elem.type !== \"tag\") {\n            return;\n        }\n        const formatHeaderCell = formatOptions.uppercaseHeaderCells !== false ? (cellNode)=>{\n            builder.pushWordTransform((str)=>str.toUpperCase());\n            formatCell(cellNode);\n            builder.popWordTransform();\n        } : formatCell;\n        switch(elem.name){\n            case \"thead\":\n            case \"tbody\":\n            case \"tfoot\":\n            case \"center\":\n                elem.children.forEach(walkTable);\n                return;\n            case \"tr\":\n                {\n                    builder.openTableRow();\n                    for (const childOfTr of elem.children){\n                        if (childOfTr.type !== \"tag\") {\n                            continue;\n                        }\n                        switch(childOfTr.name){\n                            case \"th\":\n                                {\n                                    formatHeaderCell(childOfTr);\n                                    break;\n                                }\n                            case \"td\":\n                                {\n                                    formatCell(childOfTr);\n                                    break;\n                                }\n                        }\n                    }\n                    builder.closeTableRow();\n                    break;\n                }\n        }\n    }\n}\nvar textFormatters = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    anchor: formatAnchor,\n    blockquote: formatBlockquote,\n    dataTable: formatDataTable,\n    heading: formatHeading,\n    horizontalLine: formatHorizontalLine,\n    image: formatImage,\n    lineBreak: formatLineBreak,\n    orderedList: formatOrderedList,\n    paragraph: formatParagraph,\n    pre: formatPre,\n    table: formatTable,\n    unorderedList: formatUnorderedList,\n    wbr: formatWbr\n});\n/**\n * Default options.\n *\n * @constant\n * @type { Options }\n * @default\n * @private\n */ const DEFAULT_OPTIONS = {\n    baseElements: {\n        selectors: [\n            \"body\"\n        ],\n        orderBy: \"selectors\",\n        returnDomByDefault: true\n    },\n    decodeEntities: true,\n    encodeCharacters: {},\n    formatters: {},\n    limits: {\n        ellipsis: \"...\",\n        maxBaseElements: undefined,\n        maxChildNodes: undefined,\n        maxDepth: undefined,\n        maxInputLength: 1 << 24 // 16_777_216\n    },\n    longWordSplit: {\n        forceWrapOnLimit: false,\n        wrapCharacters: []\n    },\n    preserveNewlines: false,\n    selectors: [\n        {\n            selector: \"*\",\n            format: \"inline\"\n        },\n        {\n            selector: \"a\",\n            format: \"anchor\",\n            options: {\n                baseUrl: null,\n                hideLinkHrefIfSameAsText: false,\n                ignoreHref: false,\n                linkBrackets: [\n                    \"[\",\n                    \"]\"\n                ],\n                noAnchorUrl: true\n            }\n        },\n        {\n            selector: \"article\",\n            format: \"block\",\n            options: {\n                leadingLineBreaks: 1,\n                trailingLineBreaks: 1\n            }\n        },\n        {\n            selector: \"aside\",\n            format: \"block\",\n            options: {\n                leadingLineBreaks: 1,\n                trailingLineBreaks: 1\n            }\n        },\n        {\n            selector: \"blockquote\",\n            format: \"blockquote\",\n            options: {\n                leadingLineBreaks: 2,\n                trailingLineBreaks: 2,\n                trimEmptyLines: true\n            }\n        },\n        {\n            selector: \"br\",\n            format: \"lineBreak\"\n        },\n        {\n            selector: \"div\",\n            format: \"block\",\n            options: {\n                leadingLineBreaks: 1,\n                trailingLineBreaks: 1\n            }\n        },\n        {\n            selector: \"footer\",\n            format: \"block\",\n            options: {\n                leadingLineBreaks: 1,\n                trailingLineBreaks: 1\n            }\n        },\n        {\n            selector: \"form\",\n            format: \"block\",\n            options: {\n                leadingLineBreaks: 1,\n                trailingLineBreaks: 1\n            }\n        },\n        {\n            selector: \"h1\",\n            format: \"heading\",\n            options: {\n                leadingLineBreaks: 3,\n                trailingLineBreaks: 2,\n                uppercase: true\n            }\n        },\n        {\n            selector: \"h2\",\n            format: \"heading\",\n            options: {\n                leadingLineBreaks: 3,\n                trailingLineBreaks: 2,\n                uppercase: true\n            }\n        },\n        {\n            selector: \"h3\",\n            format: \"heading\",\n            options: {\n                leadingLineBreaks: 3,\n                trailingLineBreaks: 2,\n                uppercase: true\n            }\n        },\n        {\n            selector: \"h4\",\n            format: \"heading\",\n            options: {\n                leadingLineBreaks: 2,\n                trailingLineBreaks: 2,\n                uppercase: true\n            }\n        },\n        {\n            selector: \"h5\",\n            format: \"heading\",\n            options: {\n                leadingLineBreaks: 2,\n                trailingLineBreaks: 2,\n                uppercase: true\n            }\n        },\n        {\n            selector: \"h6\",\n            format: \"heading\",\n            options: {\n                leadingLineBreaks: 2,\n                trailingLineBreaks: 2,\n                uppercase: true\n            }\n        },\n        {\n            selector: \"header\",\n            format: \"block\",\n            options: {\n                leadingLineBreaks: 1,\n                trailingLineBreaks: 1\n            }\n        },\n        {\n            selector: \"hr\",\n            format: \"horizontalLine\",\n            options: {\n                leadingLineBreaks: 2,\n                length: undefined,\n                trailingLineBreaks: 2\n            }\n        },\n        {\n            selector: \"img\",\n            format: \"image\",\n            options: {\n                baseUrl: null,\n                linkBrackets: [\n                    \"[\",\n                    \"]\"\n                ]\n            }\n        },\n        {\n            selector: \"main\",\n            format: \"block\",\n            options: {\n                leadingLineBreaks: 1,\n                trailingLineBreaks: 1\n            }\n        },\n        {\n            selector: \"nav\",\n            format: \"block\",\n            options: {\n                leadingLineBreaks: 1,\n                trailingLineBreaks: 1\n            }\n        },\n        {\n            selector: \"ol\",\n            format: \"orderedList\",\n            options: {\n                leadingLineBreaks: 2,\n                trailingLineBreaks: 2\n            }\n        },\n        {\n            selector: \"p\",\n            format: \"paragraph\",\n            options: {\n                leadingLineBreaks: 2,\n                trailingLineBreaks: 2\n            }\n        },\n        {\n            selector: \"pre\",\n            format: \"pre\",\n            options: {\n                leadingLineBreaks: 2,\n                trailingLineBreaks: 2\n            }\n        },\n        {\n            selector: \"section\",\n            format: \"block\",\n            options: {\n                leadingLineBreaks: 1,\n                trailingLineBreaks: 1\n            }\n        },\n        {\n            selector: \"table\",\n            format: \"table\",\n            options: {\n                colSpacing: 3,\n                leadingLineBreaks: 2,\n                maxColumnWidth: 60,\n                rowSpacing: 0,\n                trailingLineBreaks: 2,\n                uppercaseHeaderCells: true\n            }\n        },\n        {\n            selector: \"ul\",\n            format: \"unorderedList\",\n            options: {\n                itemPrefix: \" * \",\n                leadingLineBreaks: 2,\n                trailingLineBreaks: 2\n            }\n        },\n        {\n            selector: \"wbr\",\n            format: \"wbr\"\n        }\n    ],\n    tables: [],\n    whitespaceCharacters: \" \t\\r\\n\\f​\",\n    wordwrap: 80\n};\nconst concatMerge = (acc, src, options)=>[\n        ...acc,\n        ...src\n    ];\nconst overwriteMerge = (acc, src, options)=>[\n        ...src\n    ];\nconst selectorsMerge = (acc, src, options)=>acc.some((s)=>typeof s === \"object\") ? concatMerge(acc, src) // selectors\n     : overwriteMerge(acc, src) // baseElements.selectors\n;\n/**\n * Preprocess options, compile selectors into a decision tree,\n * return a function intended for batch processing.\n *\n * @param   { Options } [options = {}]   HtmlToText options.\n * @returns { (html: string, metadata?: any) => string } Pre-configured converter function.\n * @static\n */ function compile(options = {}) {\n    options = merge__default[\"default\"](DEFAULT_OPTIONS, options, {\n        arrayMerge: overwriteMerge,\n        customMerge: (key)=>key === \"selectors\" ? selectorsMerge : undefined\n    });\n    options.formatters = Object.assign({}, genericFormatters, textFormatters, options.formatters);\n    options.selectors = mergeDuplicatesPreferLast(options.selectors, (s)=>s.selector);\n    handleDeprecatedOptions(options);\n    return compile$1(options);\n}\n/**\n * Convert given HTML content to plain text string.\n *\n * @param   { string }  html           HTML content to convert.\n * @param   { Options } [options = {}] HtmlToText options.\n * @param   { any }     [metadata]     Optional metadata for HTML document, for use in formatters.\n * @returns { string }                 Plain text string.\n * @static\n *\n * @example\n * const { convert } = require('html-to-text');\n * const text = convert('<h1>Hello World</h1>', {\n *   wordwrap: 130\n * });\n * console.log(text); // HELLO WORLD\n */ function convert(html, options = {}, metadata = undefined) {\n    return compile(options)(html, metadata);\n}\n/**\n * Map previously existing and now deprecated options to the new options layout.\n * This is a subject for cleanup in major releases.\n *\n * @param { Options } options HtmlToText options.\n */ function handleDeprecatedOptions(options) {\n    if (options.tags) {\n        const tagDefinitions = Object.entries(options.tags).map(([selector, definition])=>({\n                ...definition,\n                selector: selector || \"*\"\n            }));\n        options.selectors.push(...tagDefinitions);\n        options.selectors = mergeDuplicatesPreferLast(options.selectors, (s)=>s.selector);\n    }\n    function set(obj, path, value) {\n        const valueKey = path.pop();\n        for (const key of path){\n            let nested = obj[key];\n            if (!nested) {\n                nested = {};\n                obj[key] = nested;\n            }\n            obj = nested;\n        }\n        obj[valueKey] = value;\n    }\n    if (options[\"baseElement\"]) {\n        const baseElement = options[\"baseElement\"];\n        set(options, [\n            \"baseElements\",\n            \"selectors\"\n        ], Array.isArray(baseElement) ? baseElement : [\n            baseElement\n        ]);\n    }\n    if (options[\"returnDomByDefault\"] !== undefined) {\n        set(options, [\n            \"baseElements\",\n            \"returnDomByDefault\"\n        ], options[\"returnDomByDefault\"]);\n    }\n    for (const definition of options.selectors){\n        if (definition.format === \"anchor\" && get(definition, [\n            \"options\",\n            \"noLinkBrackets\"\n        ])) {\n            set(definition, [\n                \"options\",\n                \"linkBrackets\"\n            ], false);\n        }\n    }\n}\nexports.compile = compile;\nexports.convert = convert;\nexports.htmlToText = convert;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWwtdG8tdGV4dC9saWIvaHRtbC10by10ZXh0LmNqcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUU3RCxJQUFJQyxvQkFBb0JDLG1CQUFPQSxDQUFDO0FBQ2hDLElBQUlDLGNBQWNELG1CQUFPQSxDQUFDO0FBQzFCLElBQUlFLFdBQVdGLG1CQUFPQSxDQUFDO0FBQ3ZCLElBQUlHLFFBQVFILG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlJLGdCQUFnQkosbUJBQU9BLENBQUM7QUFFNUIsU0FBU0ssc0JBQXVCQyxDQUFDO0lBQUksT0FBT0EsS0FBSyxPQUFPQSxNQUFNLFlBQVksYUFBYUEsSUFBSUEsSUFBSTtRQUFFLFdBQVdBO0lBQUU7QUFBRztBQUVqSCxJQUFJQyxpQkFBaUIsV0FBVyxHQUFFRixzQkFBc0JGO0FBRXhEOzs7Ozs7Ozs7Q0FTQyxHQUNELFNBQVNLLHNCQUF1QkMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLElBQUksSUFBTUMsU0FBUztJQUN2RCxJQUFJSCxNQUFNRyxXQUFXO1FBQ25CLE1BQU1DLEtBQUssU0FBVSxHQUFHQyxJQUFJO1lBQUksT0FBT0osRUFBRUcsT0FBT0M7UUFBTztRQUN2RCxPQUFPRDtJQUNUO0lBQ0EsSUFBSUosS0FBSyxHQUFHO1FBQ1YsT0FBTyxTQUFVLEdBQUdLLElBQUk7WUFBSSxPQUFPSixFQUFFRixzQkFBc0JDLElBQUksR0FBR0MsR0FBR0MsT0FBT0c7UUFBTztJQUNyRjtJQUNBLE9BQU9IO0FBQ1Q7QUFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU0ksY0FBZUMsR0FBRyxFQUFFQyxJQUFJO0lBQy9CLElBQUlDLFFBQVE7SUFDWixJQUFJQyxNQUFNSCxJQUFJSSxNQUFNO0lBQ3BCLE1BQU9GLFFBQVFDLE9BQU9ILEdBQUcsQ0FBQ0UsTUFBTSxLQUFLRCxLQUFNO1FBQUUsRUFBRUM7SUFBTztJQUN0RCxNQUFP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QUFTekwsSUFBS1UsR0FBRyxFQUFFQyxJQUFJLEVBQUVsRCxLQUFLO1FBQzVCLE1BQU1zYixXQUFXcFksS0FBS3lDLEdBQUc7UUFDekIsS0FBSyxNQUFNckQsT0FBT1ksS0FBTTtZQUN0QixJQUFJcVksU0FBU3RZLEdBQUcsQ0FBQ1gsSUFBSTtZQUNyQixJQUFJLENBQUNpWixRQUFRO2dCQUNYQSxTQUFTLENBQUM7Z0JBQ1Z0WSxHQUFHLENBQUNYLElBQUksR0FBR2laO1lBQ2I7WUFDQXRZLE1BQU1zWTtRQUNSO1FBQ0F0WSxHQUFHLENBQUNxWSxTQUFTLEdBQUd0YjtJQUNsQjtJQUVBLElBQUlnRCxPQUFPLENBQUMsY0FBYyxFQUFFO1FBQzFCLE1BQU13WSxjQUFjeFksT0FBTyxDQUFDLGNBQWM7UUFDMUNULElBQ0VTLFNBQ0E7WUFBQztZQUFnQjtTQUFZLEVBQzVCOEMsTUFBTTJWLE9BQU8sQ0FBQ0QsZUFBZUEsY0FBYztZQUFDQTtTQUFZO0lBRTdEO0lBQ0EsSUFBSXhZLE9BQU8sQ0FBQyxxQkFBcUIsS0FBS2xDLFdBQVc7UUFDL0N5QixJQUFJUyxTQUFTO1lBQUM7WUFBZ0I7U0FBcUIsRUFBRUEsT0FBTyxDQUFDLHFCQUFxQjtJQUNwRjtJQUVBLEtBQUssTUFBTXFZLGNBQWNyWSxRQUFRNEssU0FBUyxDQUFFO1FBQzFDLElBQUl5TixXQUFXdE4sTUFBTSxLQUFLLFlBQVl0TCxJQUFJNFksWUFBWTtZQUFDO1lBQVc7U0FBaUIsR0FBRztZQUNwRjlZLElBQUk4WSxZQUFZO2dCQUFDO2dCQUFXO2FBQWUsRUFBRTtRQUMvQztJQUNGO0FBQ0Y7QUFFQXRiLGVBQWUsR0FBRythO0FBQ2xCL2EsZUFBZSxHQUFHbWI7QUFDbEJuYixrQkFBa0IsR0FBR21iIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGFja2hhcnZhcmQvLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2h0bWwtdG8tdGV4dC9saWIvaHRtbC10by10ZXh0LmNqcz9hMzY2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIHBsdWdpbkh0bWxwYXJzZXIyID0gcmVxdWlyZSgnQHNlbGRlcmVlL3BsdWdpbi1odG1scGFyc2VyMicpO1xudmFyIGh0bWxwYXJzZXIyID0gcmVxdWlyZSgnaHRtbHBhcnNlcjInKTtcbnZhciBzZWxkZXJlZSA9IHJlcXVpcmUoJ3NlbGRlcmVlJyk7XG52YXIgbWVyZ2UgPSByZXF1aXJlKCdkZWVwbWVyZ2UnKTtcbnZhciBkb21TZXJpYWxpemVyID0gcmVxdWlyZSgnZG9tLXNlcmlhbGl6ZXInKTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0TGVnYWN5IChlKSB7IHJldHVybiBlICYmIHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gZSA/IGUgOiB7ICdkZWZhdWx0JzogZSB9OyB9XG5cbnZhciBtZXJnZV9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3kobWVyZ2UpO1xuXG4vKipcbiAqIE1ha2UgYSByZWN1cnNpdmUgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgcnVuIHRvIGEgZ2l2ZW4gZGVwdGhcbiAqIGFuZCBzd2l0Y2hlcyB0byBhbiBhbHRlcm5hdGl2ZSBmdW5jdGlvbiBhdCB0aGF0IGRlcHRoLiBcXFxuICogTm8gbGltaXRhdGlvbiBpZiBgbmAgaXMgYHVuZGVmaW5lZGAgKEp1c3Qgd3JhcHMgYGZgIGluIHRoYXQgY2FzZSkuXG4gKlxuICogQHBhcmFtICAgeyBudW1iZXIgfCB1bmRlZmluZWQgfSBuICAgQWxsb3dlZCBkZXB0aCBvZiByZWN1cnNpb24uIGB1bmRlZmluZWRgIGZvciBubyBsaW1pdGF0aW9uLlxuICogQHBhcmFtICAgeyBGdW5jdGlvbiB9ICAgICAgICAgICBmICAgRnVuY3Rpb24gdGhhdCBhY2NlcHRzIHJlY3Vyc2l2ZSBjYWxsYmFjayBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXG4gKiBAcGFyYW0gICB7IEZ1bmN0aW9uIH0gICAgICAgICAgIFtnXSBGdW5jdGlvbiB0byBydW4gaW5zdGVhZCwgd2hlbiBtYXhpbXVtIGRlcHRoIHdhcyByZWFjaGVkLiBEbyBub3RoaW5nIGJ5IGRlZmF1bHQuXG4gKiBAcmV0dXJucyB7IEZ1bmN0aW9uIH1cbiAqL1xuZnVuY3Rpb24gbGltaXRlZERlcHRoUmVjdXJzaXZlIChuLCBmLCBnID0gKCkgPT4gdW5kZWZpbmVkKSB7XG4gIGlmIChuID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBmMSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7IHJldHVybiBmKGYxLCAuLi5hcmdzKTsgfTtcbiAgICByZXR1cm4gZjE7XG4gIH1cbiAgaWYgKG4gPj0gMCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykgeyByZXR1cm4gZihsaW1pdGVkRGVwdGhSZWN1cnNpdmUobiAtIDEsIGYsIGcpLCAuLi5hcmdzKTsgfTtcbiAgfVxuICByZXR1cm4gZztcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHNhbWUgc3RyaW5nIG9yIGEgc3Vic3RyaW5nIHdpdGhcbiAqIHRoZSBnaXZlbiBjaGFyYWN0ZXIgb2NjdXJyZW5jZXMgcmVtb3ZlZCBmcm9tIGVhY2ggc2lkZS5cbiAqXG4gKiBAcGFyYW0gICB7IHN0cmluZyB9IHN0ciAgQSBzdHJpbmcgdG8gdHJpbS5cbiAqIEBwYXJhbSAgIHsgc3RyaW5nIH0gY2hhciBBIGNoYXJhY3RlciB0byBiZSB0cmltbWVkLlxuICogQHJldHVybnMgeyBzdHJpbmcgfVxuICovXG5mdW5jdGlvbiB0cmltQ2hhcmFjdGVyIChzdHIsIGNoYXIpIHtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGVuZCA9IHN0ci5sZW5ndGg7XG4gIHdoaWxlIChzdGFydCA8IGVuZCAmJiBzdHJbc3RhcnRdID09PSBjaGFyKSB7ICsrc3RhcnQ7IH1cbiAgd2hpbGUgKGVuZCA+IHN0YXJ0ICYmIHN0cltlbmQgLSAxXSA9PT0gY2hhcikgeyAtLWVuZDsgfVxuICByZXR1cm4gKHN0YXJ0ID4gMCB8fCBlbmQgPCBzdHIubGVuZ3RoKVxuICAgID8gc3RyLnN1YnN0cmluZyhzdGFydCwgZW5kKVxuICAgIDogc3RyO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgc2FtZSBzdHJpbmcgb3IgYSBzdWJzdHJpbmcgd2l0aFxuICogdGhlIGdpdmVuIGNoYXJhY3RlciBvY2N1cnJlbmNlcyByZW1vdmVkIGZyb20gdGhlIGVuZCBvbmx5LlxuICpcbiAqIEBwYXJhbSAgIHsgc3RyaW5nIH0gc3RyICBBIHN0cmluZyB0byB0cmltLlxuICogQHBhcmFtICAgeyBzdHJpbmcgfSBjaGFyIEEgY2hhcmFjdGVyIHRvIGJlIHRyaW1tZWQuXG4gKiBAcmV0dXJucyB7IHN0cmluZyB9XG4gKi9cbmZ1bmN0aW9uIHRyaW1DaGFyYWN0ZXJFbmQgKHN0ciwgY2hhcikge1xuICBsZXQgZW5kID0gc3RyLmxlbmd0aDtcbiAgd2hpbGUgKGVuZCA+IDAgJiYgc3RyW2VuZCAtIDFdID09PSBjaGFyKSB7IC0tZW5kOyB9XG4gIHJldHVybiAoZW5kIDwgc3RyLmxlbmd0aClcbiAgICA/IHN0ci5zdWJzdHJpbmcoMCwgZW5kKVxuICAgIDogc3RyO1xufVxuXG4vKipcbiAqIFJldHVybiBhIG5ldyBzdHJpbmcgd2lsbCBhbGwgY2hhcmFjdGVycyByZXBsYWNlZCB3aXRoIHVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlcy5cbiAqIFRoaXMgZXh0cmVtZSBraW5kIG9mIGVzY2FwaW5nIGNhbiB1c2VkIHRvIGJlIHNhZmVseSBjb21wb3NlIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG4gKlxuICogQHBhcmFtIHsgc3RyaW5nIH0gc3RyIEEgc3RyaW5nIHRvIGVzY2FwZS5cbiAqIEByZXR1cm5zIHsgc3RyaW5nIH0gQSBzdHJpbmcgb2YgdW5pY29kZSBlc2NhcGUgc2VxdWVuY2VzLlxuICovXG5mdW5jdGlvbiB1bmljb2RlRXNjYXBlIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bXFxzXFxTXS9nLCBjID0+ICdcXFxcdScgKyBjLmNoYXJDb2RlQXQoKS50b1N0cmluZygxNikucGFkU3RhcnQoNCwgJzAnKSk7XG59XG5cbi8qKlxuICogRGVkdXBsaWNhdGUgYW4gYXJyYXkgYnkgYSBnaXZlbiBrZXkgY2FsbGJhY2suXG4gKiBJdGVtIHByb3BlcnRpZXMgYXJlIG1lcmdlZCByZWN1cnNpdmVseSBhbmQgd2l0aCB0aGUgcHJlZmVyZW5jZSBmb3IgbGFzdCBkZWZpbmVkIHZhbHVlcy5cbiAqIE9mIGl0ZW1zIHdpdGggdGhlIHNhbWUga2V5LCBtZXJnZWQgaXRlbSB0YWtlcyB0aGUgcGxhY2Ugb2YgdGhlIGxhc3QgaXRlbSxcbiAqIG90aGVycyBhcmUgb21pdHRlZC5cbiAqXG4gKiBAcGFyYW0geyBhbnlbXSB9IGl0ZW1zIEFuIGFycmF5IHRvIGRlZHVwbGljYXRlLlxuICogQHBhcmFtIHsgKHg6IGFueSkgPT4gc3RyaW5nIH0gZ2V0S2V5IENhbGxiYWNrIHRvIGdldCBhIHZhbHVlIHRoYXQgZGlzdGluZ3Vpc2hlcyB1bmlxdWUgaXRlbXMuXG4gKiBAcmV0dXJucyB7IGFueVtdIH1cbiAqL1xuZnVuY3Rpb24gbWVyZ2VEdXBsaWNhdGVzUHJlZmVyTGFzdCAoaXRlbXMsIGdldEtleSkge1xuICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG4gIGZvciAobGV0IGkgPSBpdGVtcy5sZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuICAgIGNvbnN0IGtleSA9IGdldEtleShpdGVtKTtcbiAgICBtYXAuc2V0KFxuICAgICAga2V5LFxuICAgICAgKG1hcC5oYXMoa2V5KSlcbiAgICAgICAgPyBtZXJnZV9fZGVmYXVsdFtcImRlZmF1bHRcIl0oaXRlbSwgbWFwLmdldChrZXkpLCB7IGFycmF5TWVyZ2U6IG92ZXJ3cml0ZU1lcmdlJDEgfSlcbiAgICAgICAgOiBpdGVtXG4gICAgKTtcbiAgfVxuICByZXR1cm4gWy4uLm1hcC52YWx1ZXMoKV0ucmV2ZXJzZSgpO1xufVxuXG5jb25zdCBvdmVyd3JpdGVNZXJnZSQxID0gKGFjYywgc3JjLCBvcHRpb25zKSA9PiBbLi4uc3JjXTtcblxuLyoqXG4gKiBHZXQgYSBuZXN0ZWQgcHJvcGVydHkgZnJvbSBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtICAgeyBvYmplY3QgfSAgIG9iaiAgVGhlIG9iamVjdCB0byBxdWVyeSBmb3IgdGhlIHZhbHVlLlxuICogQHBhcmFtICAgeyBzdHJpbmdbXSB9IHBhdGggVGhlIHBhdGggdG8gdGhlIHByb3BlcnR5LlxuICogQHJldHVybnMgeyBhbnkgfVxuICovXG5mdW5jdGlvbiBnZXQgKG9iaiwgcGF0aCkge1xuICBmb3IgKGNvbnN0IGtleSBvZiBwYXRoKSB7XG4gICAgaWYgKCFvYmopIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICAgIG9iaiA9IG9ialtrZXldO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogQ29udmVydCBhIG51bWJlciBpbnRvIGFscGhhYmV0aWMgc2VxdWVuY2UgcmVwcmVzZW50YXRpb24gKFNlcXVlbmNlIHdpdGhvdXQgemVyb2VzKS5cbiAqXG4gKiBGb3IgZXhhbXBsZTogYGEsIC4uLiwgeiwgYWEsIC4uLiwgenosIGFhYSwgLi4uYC5cbiAqXG4gKiBAcGFyYW0gICB7IG51bWJlciB9IG51bSAgICAgICAgICAgICAgTnVtYmVyIHRvIGNvbnZlcnQuIE11c3QgYmUgPj0gMS5cbiAqIEBwYXJhbSAgIHsgc3RyaW5nIH0gW2Jhc2VDaGFyID0gJ2EnXSBDaGFyYWN0ZXIgZm9yIDEgaW4gdGhlIHNlcXVlbmNlLlxuICogQHBhcmFtICAgeyBudW1iZXIgfSBbYmFzZSA9IDI2XSAgICAgIE51bWJlciBvZiBjaGFyYWN0ZXJzIGluIHRoZSBzZXF1ZW5jZS5cbiAqIEByZXR1cm5zIHsgc3RyaW5nIH1cbiAqL1xuZnVuY3Rpb24gbnVtYmVyVG9MZXR0ZXJTZXF1ZW5jZSAobnVtLCBiYXNlQ2hhciA9ICdhJywgYmFzZSA9IDI2KSB7XG4gIGNvbnN0IGRpZ2l0cyA9IFtdO1xuICBkbyB7XG4gICAgbnVtIC09IDE7XG4gICAgZGlnaXRzLnB1c2gobnVtICUgYmFzZSk7XG4gICAgbnVtID0gKG51bSAvIGJhc2UpID4+IDA7IC8vIHF1aWNrIGBmbG9vcmBcbiAgfSB3aGlsZSAobnVtID4gMCk7XG4gIGNvbnN0IGJhc2VDb2RlID0gYmFzZUNoYXIuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGRpZ2l0c1xuICAgIC5yZXZlcnNlKClcbiAgICAubWFwKG4gPT4gU3RyaW5nLmZyb21DaGFyQ29kZShiYXNlQ29kZSArIG4pKVxuICAgIC5qb2luKCcnKTtcbn1cblxuY29uc3QgSSA9IFsnSScsICdYJywgJ0MnLCAnTSddO1xuY29uc3QgViA9IFsnVicsICdMJywgJ0QnXTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgbnVtYmVyIHRvIGl0J3MgUm9tYW4gcmVwcmVzZW50YXRpb24uIE5vIGxhcmdlIG51bWJlcnMgZXh0ZW5zaW9uLlxuICpcbiAqIEBwYXJhbSAgIHsgbnVtYmVyIH0gbnVtIE51bWJlciB0byBjb252ZXJ0LiBgMCA8IG51bSA8PSAzOTk5YC5cbiAqIEByZXR1cm5zIHsgc3RyaW5nIH1cbiAqL1xuZnVuY3Rpb24gbnVtYmVyVG9Sb21hbiAobnVtKSB7XG4gIHJldHVybiBbLi4uKG51bSkgKyAnJ11cbiAgICAubWFwKG4gPT4gK24pXG4gICAgLnJldmVyc2UoKVxuICAgIC5tYXAoKHYsIGkpID0+ICgodiAlIDUgPCA0KVxuICAgICAgPyAodiA8IDUgPyAnJyA6IFZbaV0pICsgSVtpXS5yZXBlYXQodiAlIDUpXG4gICAgICA6IElbaV0gKyAodiA8IDUgPyBWW2ldIDogSVtpICsgMV0pKSlcbiAgICAucmV2ZXJzZSgpXG4gICAgLmpvaW4oJycpO1xufVxuXG4vKipcbiAqIEhlbHBzIHRvIGJ1aWxkIHRleHQgZnJvbSB3b3Jkcy5cbiAqL1xuY2xhc3MgSW5saW5lVGV4dEJ1aWxkZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBJbmxpbmVUZXh0QnVpbGRlci5cbiAgICpcbiAgICogSWYgYG1heExpbmVMZW5ndGhgIGlzIG5vdCBwcm92aWRlZCB0aGVuIGl0IGlzIGVpdGhlciBgb3B0aW9ucy53b3Jkd3JhcGAgb3IgdW5saW1pdGVkLlxuICAgKlxuICAgKiBAcGFyYW0geyBPcHRpb25zIH0gb3B0aW9ucyAgICAgICAgICAgSHRtbFRvVGV4dCBvcHRpb25zLlxuICAgKiBAcGFyYW0geyBudW1iZXIgfSAgWyBtYXhMaW5lTGVuZ3RoIF0gVGhpcyBidWlsZGVyIHdpbGwgdHJ5IHRvIHdyYXAgdGV4dCB0byBmaXQgdGhpcyBsaW5lIGxlbmd0aC5cbiAgICovXG4gIGNvbnN0cnVjdG9yIChvcHRpb25zLCBtYXhMaW5lTGVuZ3RoID0gdW5kZWZpbmVkKSB7XG4gICAgLyoqIEB0eXBlIHsgc3RyaW5nW11bXSB9ICovXG4gICAgdGhpcy5saW5lcyA9IFtdO1xuICAgIC8qKiBAdHlwZSB7IHN0cmluZ1tdIH0gICAqL1xuICAgIHRoaXMubmV4dExpbmVXb3JkcyA9IFtdO1xuICAgIHRoaXMubWF4TGluZUxlbmd0aCA9IG1heExpbmVMZW5ndGggfHwgb3B0aW9ucy53b3Jkd3JhcCB8fCBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIHRoaXMubmV4dExpbmVBdmFpbGFibGVDaGFycyA9IHRoaXMubWF4TGluZUxlbmd0aDtcbiAgICB0aGlzLndyYXBDaGFyYWN0ZXJzID0gZ2V0KG9wdGlvbnMsIFsnbG9uZ1dvcmRTcGxpdCcsICd3cmFwQ2hhcmFjdGVycyddKSB8fCBbXTtcbiAgICB0aGlzLmZvcmNlV3JhcE9uTGltaXQgPSBnZXQob3B0aW9ucywgWydsb25nV29yZFNwbGl0JywgJ2ZvcmNlV3JhcE9uTGltaXQnXSkgfHwgZmFsc2U7XG5cbiAgICB0aGlzLnN0YXNoZWRTcGFjZSA9IGZhbHNlO1xuICAgIHRoaXMud29yZEJyZWFrT3Bwb3J0dW5pdHkgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBuZXcgd29yZC5cbiAgICpcbiAgICogQHBhcmFtIHsgc3RyaW5nIH0gd29yZCBBIHdvcmQgdG8gYWRkLlxuICAgKiBAcGFyYW0geyBib29sZWFuIH0gW25vV3JhcF0gRG9uJ3Qgd3JhcCB0ZXh0IGV2ZW4gaWYgdGhlIGxpbmUgaXMgdG9vIGxvbmcuXG4gICAqL1xuICBwdXNoV29yZCAod29yZCwgbm9XcmFwID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5uZXh0TGluZUF2YWlsYWJsZUNoYXJzIDw9IDAgJiYgIW5vV3JhcCkge1xuICAgICAgdGhpcy5zdGFydE5ld0xpbmUoKTtcbiAgICB9XG4gICAgY29uc3QgaXNMaW5lU3RhcnQgPSB0aGlzLm5leHRMaW5lV29yZHMubGVuZ3RoID09PSAwO1xuICAgIGNvbnN0IGNvc3QgPSB3b3JkLmxlbmd0aCArIChpc0xpbmVTdGFydCA/IDAgOiAxKTtcbiAgICBpZiAoKGNvc3QgPD0gdGhpcy5uZXh0TGluZUF2YWlsYWJsZUNoYXJzKSB8fCBub1dyYXApIHsgLy8gRml0cyBpbnRvIGF2YWlsYWJsZSBidWRnZXRcblxuICAgICAgdGhpcy5uZXh0TGluZVdvcmRzLnB1c2god29yZCk7XG4gICAgICB0aGlzLm5leHRMaW5lQXZhaWxhYmxlQ2hhcnMgLT0gY29zdDtcblxuICAgIH0gZWxzZSB7IC8vIERvZXMgbm90IGZpdCAtIHRyeSB0byBzcGxpdCB0aGUgd29yZFxuXG4gICAgICAvLyBUaGUgd29yZCBpcyBtb3ZlZCB0byBhIG5ldyBsaW5lIC0gcHJlZmVyIHRvIHdyYXAgYmV0d2VlbiB3b3Jkcy5cbiAgICAgIGNvbnN0IFtmaXJzdCwgLi4ucmVzdF0gPSB0aGlzLnNwbGl0TG9uZ1dvcmQod29yZCk7XG4gICAgICBpZiAoIWlzTGluZVN0YXJ0KSB7IHRoaXMuc3RhcnROZXdMaW5lKCk7IH1cbiAgICAgIHRoaXMubmV4dExpbmVXb3Jkcy5wdXNoKGZpcnN0KTtcbiAgICAgIHRoaXMubmV4dExpbmVBdmFpbGFibGVDaGFycyAtPSBmaXJzdC5sZW5ndGg7XG4gICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcmVzdCkge1xuICAgICAgICB0aGlzLnN0YXJ0TmV3TGluZSgpO1xuICAgICAgICB0aGlzLm5leHRMaW5lV29yZHMucHVzaChwYXJ0KTtcbiAgICAgICAgdGhpcy5uZXh0TGluZUF2YWlsYWJsZUNoYXJzIC09IHBhcnQubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBvcCBhIHdvcmQgZnJvbSB0aGUgY3VycmVudGx5IGJ1aWx0IGxpbmUuXG4gICAqIFRoaXMgZG9lc24ndCBhZmZlY3QgY29tcGxldGVkIGxpbmVzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7IHN0cmluZyB9XG4gICAqL1xuICBwb3BXb3JkICgpIHtcbiAgICBjb25zdCBsYXN0V29yZCA9IHRoaXMubmV4dExpbmVXb3Jkcy5wb3AoKTtcbiAgICBpZiAobGFzdFdvcmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgaXNMaW5lU3RhcnQgPSB0aGlzLm5leHRMaW5lV29yZHMubGVuZ3RoID09PSAwO1xuICAgICAgY29uc3QgY29zdCA9IGxhc3RXb3JkLmxlbmd0aCArIChpc0xpbmVTdGFydCA/IDAgOiAxKTtcbiAgICAgIHRoaXMubmV4dExpbmVBdmFpbGFibGVDaGFycyArPSBjb3N0O1xuICAgIH1cbiAgICByZXR1cm4gbGFzdFdvcmQ7XG4gIH1cblxuICAvKipcbiAgICogQ29uY2F0IGEgd29yZCB0byB0aGUgbGFzdCB3b3JkIGFscmVhZHkgaW4gdGhlIGJ1aWxkZXIuXG4gICAqIEFkZHMgYSBuZXcgd29yZCBpbiBjYXNlIHRoZXJlIGFyZSBubyB3b3JkcyB5ZXQgaW4gdGhlIGxhc3QgbGluZS5cbiAgICpcbiAgICogQHBhcmFtIHsgc3RyaW5nIH0gd29yZCBBIHdvcmQgdG8gYmUgY29uY2F0ZW5hdGVkLlxuICAgKiBAcGFyYW0geyBib29sZWFuIH0gW25vV3JhcF0gRG9uJ3Qgd3JhcCB0ZXh0IGV2ZW4gaWYgdGhlIGxpbmUgaXMgdG9vIGxvbmcuXG4gICAqL1xuICBjb25jYXRXb3JkICh3b3JkLCBub1dyYXAgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLndvcmRCcmVha09wcG9ydHVuaXR5ICYmIHdvcmQubGVuZ3RoID4gdGhpcy5uZXh0TGluZUF2YWlsYWJsZUNoYXJzKSB7XG4gICAgICB0aGlzLnB1c2hXb3JkKHdvcmQsIG5vV3JhcCk7XG4gICAgICB0aGlzLndvcmRCcmVha09wcG9ydHVuaXR5ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxhc3RXb3JkID0gdGhpcy5wb3BXb3JkKCk7XG4gICAgICB0aGlzLnB1c2hXb3JkKChsYXN0V29yZCkgPyBsYXN0V29yZC5jb25jYXQod29yZCkgOiB3b3JkLCBub1dyYXApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgY3VycmVudCBsaW5lIChhbmQgbW9yZSBlbXB0eSBsaW5lcyBpZiBwcm92aWRlZCBhcmd1bWVudCA+IDEpIHRvIHRoZSBsaXN0IG9mIGNvbXBsZXRlIGxpbmVzIGFuZCBzdGFydCBhIG5ldyBvbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7IG51bWJlciB9IG4gTnVtYmVyIG9mIGxpbmUgYnJlYWtzIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgcmVzdWx0aW5nIHN0cmluZy5cbiAgICovXG4gIHN0YXJ0TmV3TGluZSAobiA9IDEpIHtcbiAgICB0aGlzLmxpbmVzLnB1c2godGhpcy5uZXh0TGluZVdvcmRzKTtcbiAgICBpZiAobiA+IDEpIHtcbiAgICAgIHRoaXMubGluZXMucHVzaCguLi5BcnJheS5mcm9tKHsgbGVuZ3RoOiBuIC0gMSB9LCAoKSA9PiBbXSkpO1xuICAgIH1cbiAgICB0aGlzLm5leHRMaW5lV29yZHMgPSBbXTtcbiAgICB0aGlzLm5leHRMaW5lQXZhaWxhYmxlQ2hhcnMgPSB0aGlzLm1heExpbmVMZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogTm8gd29yZHMgaW4gdGhpcyBidWlsZGVyLlxuICAgKlxuICAgKiBAcmV0dXJucyB7IGJvb2xlYW4gfVxuICAgKi9cbiAgaXNFbXB0eSAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGluZXMubGVuZ3RoID09PSAwXG4gICAgICAgICYmIHRoaXMubmV4dExpbmVXb3Jkcy5sZW5ndGggPT09IDA7XG4gIH1cblxuICBjbGVhciAoKSB7XG4gICAgdGhpcy5saW5lcy5sZW5ndGggPSAwO1xuICAgIHRoaXMubmV4dExpbmVXb3Jkcy5sZW5ndGggPSAwO1xuICAgIHRoaXMubmV4dExpbmVBdmFpbGFibGVDaGFycyA9IHRoaXMubWF4TGluZUxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBKb2luIGFsbCBsaW5lcyBvZiB3b3JkcyBpbnNpZGUgdGhlIElubGluZVRleHRCdWlsZGVyIGludG8gYSBjb21wbGV0ZSBzdHJpbmcuXG4gICAqXG4gICAqIEByZXR1cm5zIHsgc3RyaW5nIH1cbiAgICovXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gWy4uLnRoaXMubGluZXMsIHRoaXMubmV4dExpbmVXb3Jkc11cbiAgICAgIC5tYXAod29yZHMgPT4gd29yZHMuam9pbignICcpKVxuICAgICAgLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0IGEgbG9uZyB3b3JkIHVwIHRvIGZpdCB3aXRoaW4gdGhlIHdvcmQgd3JhcCBsaW1pdC5cbiAgICogVXNlIGVpdGhlciBhIGNoYXJhY3RlciB0byBzcGxpdCBsb29raW5nIGJhY2sgZnJvbSB0aGUgd29yZCB3cmFwIGxpbWl0LFxuICAgKiBvciB0cnVuY2F0ZSB0byB0aGUgd29yZCB3cmFwIGxpbWl0LlxuICAgKlxuICAgKiBAcGFyYW0gICB7IHN0cmluZyB9ICAgd29yZCBJbnB1dCB3b3JkLlxuICAgKiBAcmV0dXJucyB7IHN0cmluZ1tdIH0gICAgICBQYXJ0cyBvZiB0aGUgd29yZC5cbiAgICovXG4gIHNwbGl0TG9uZ1dvcmQgKHdvcmQpIHtcbiAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgIGxldCBpZHggPSAwO1xuICAgIHdoaWxlICh3b3JkLmxlbmd0aCA+IHRoaXMubWF4TGluZUxlbmd0aCkge1xuXG4gICAgICBjb25zdCBmaXJzdExpbmUgPSB3b3JkLnN1YnN0cmluZygwLCB0aGlzLm1heExpbmVMZW5ndGgpO1xuICAgICAgY29uc3QgcmVtYWluaW5nQ2hhcnMgPSB3b3JkLnN1YnN0cmluZyh0aGlzLm1heExpbmVMZW5ndGgpO1xuXG4gICAgICBjb25zdCBzcGxpdEluZGV4ID0gZmlyc3RMaW5lLmxhc3RJbmRleE9mKHRoaXMud3JhcENoYXJhY3RlcnNbaWR4XSk7XG5cbiAgICAgIGlmIChzcGxpdEluZGV4ID4gLTEpIHsgLy8gRm91bmQgYSBjaGFyYWN0ZXIgdG8gc3BsaXQgb25cblxuICAgICAgICB3b3JkID0gZmlyc3RMaW5lLnN1YnN0cmluZyhzcGxpdEluZGV4ICsgMSkgKyByZW1haW5pbmdDaGFycztcbiAgICAgICAgcGFydHMucHVzaChmaXJzdExpbmUuc3Vic3RyaW5nKDAsIHNwbGl0SW5kZXggKyAxKSk7XG5cbiAgICAgIH0gZWxzZSB7IC8vIE5vdCBmb3VuZCBhIGNoYXJhY3RlciB0byBzcGxpdCBvblxuXG4gICAgICAgIGlkeCsrO1xuICAgICAgICBpZiAoaWR4IDwgdGhpcy53cmFwQ2hhcmFjdGVycy5sZW5ndGgpIHsgLy8gVGhlcmUgaXMgbmV4dCBjaGFyYWN0ZXIgdG8gdHJ5XG5cbiAgICAgICAgICB3b3JkID0gZmlyc3RMaW5lICsgcmVtYWluaW5nQ2hhcnM7XG5cbiAgICAgICAgfSBlbHNlIHsgLy8gTm8gbW9yZSBjaGFyYWN0ZXJzIHRvIHRyeVxuXG4gICAgICAgICAgaWYgKHRoaXMuZm9yY2VXcmFwT25MaW1pdCkge1xuICAgICAgICAgICAgcGFydHMucHVzaChmaXJzdExpbmUpO1xuICAgICAgICAgICAgd29yZCA9IHJlbWFpbmluZ0NoYXJzO1xuICAgICAgICAgICAgaWYgKHdvcmQubGVuZ3RoID4gdGhpcy5tYXhMaW5lTGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3b3JkID0gZmlyc3RMaW5lICsgcmVtYWluaW5nQ2hhcnM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfVxuICAgIHBhcnRzLnB1c2god29yZCk7IC8vIEFkZCByZW1haW5pbmcgcGFydCB0byBhcnJheVxuICAgIHJldHVybiBwYXJ0cztcbiAgfVxufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtY2xhc3Nlcy1wZXItZmlsZSAqL1xuXG5cbmNsYXNzIFN0YWNrSXRlbSB7XG4gIGNvbnN0cnVjdG9yIChuZXh0ID0gbnVsbCkgeyB0aGlzLm5leHQgPSBuZXh0OyB9XG5cbiAgZ2V0Um9vdCAoKSB7IHJldHVybiAodGhpcy5uZXh0KSA/IHRoaXMubmV4dCA6IHRoaXM7IH1cbn1cblxuY2xhc3MgQmxvY2tTdGFja0l0ZW0gZXh0ZW5kcyBTdGFja0l0ZW0ge1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucywgbmV4dCA9IG51bGwsIGxlYWRpbmdMaW5lQnJlYWtzID0gMSwgbWF4TGluZUxlbmd0aCA9IHVuZGVmaW5lZCkge1xuICAgIHN1cGVyKG5leHQpO1xuICAgIHRoaXMubGVhZGluZ0xpbmVCcmVha3MgPSBsZWFkaW5nTGluZUJyZWFrcztcbiAgICB0aGlzLmlubGluZVRleHRCdWlsZGVyID0gbmV3IElubGluZVRleHRCdWlsZGVyKG9wdGlvbnMsIG1heExpbmVMZW5ndGgpO1xuICAgIHRoaXMucmF3VGV4dCA9ICcnO1xuICAgIHRoaXMuc3Rhc2hlZExpbmVCcmVha3MgPSAwO1xuICAgIHRoaXMuaXNQcmUgPSBuZXh0ICYmIG5leHQuaXNQcmU7XG4gICAgdGhpcy5pc05vV3JhcCA9IG5leHQgJiYgbmV4dC5pc05vV3JhcDtcbiAgfVxufVxuXG5jbGFzcyBMaXN0U3RhY2tJdGVtIGV4dGVuZHMgQmxvY2tTdGFja0l0ZW0ge1xuICBjb25zdHJ1Y3RvciAoXG4gICAgb3B0aW9ucyxcbiAgICBuZXh0ID0gbnVsbCxcbiAgICB7XG4gICAgICBpbnRlclJvd0xpbmVCcmVha3MgPSAxLFxuICAgICAgbGVhZGluZ0xpbmVCcmVha3MgPSAyLFxuICAgICAgbWF4TGluZUxlbmd0aCA9IHVuZGVmaW5lZCxcbiAgICAgIG1heFByZWZpeExlbmd0aCA9IDAsXG4gICAgICBwcmVmaXhBbGlnbiA9ICdsZWZ0JyxcbiAgICB9ID0ge31cbiAgKSB7XG4gICAgc3VwZXIob3B0aW9ucywgbmV4dCwgbGVhZGluZ0xpbmVCcmVha3MsIG1heExpbmVMZW5ndGgpO1xuICAgIHRoaXMubWF4UHJlZml4TGVuZ3RoID0gbWF4UHJlZml4TGVuZ3RoO1xuICAgIHRoaXMucHJlZml4QWxpZ24gPSBwcmVmaXhBbGlnbjtcbiAgICB0aGlzLmludGVyUm93TGluZUJyZWFrcyA9IGludGVyUm93TGluZUJyZWFrcztcbiAgfVxufVxuXG5jbGFzcyBMaXN0SXRlbVN0YWNrSXRlbSBleHRlbmRzIEJsb2NrU3RhY2tJdGVtIHtcbiAgY29uc3RydWN0b3IgKFxuICAgIG9wdGlvbnMsXG4gICAgbmV4dCA9IG51bGwsXG4gICAge1xuICAgICAgbGVhZGluZ0xpbmVCcmVha3MgPSAxLFxuICAgICAgbWF4TGluZUxlbmd0aCA9IHVuZGVmaW5lZCxcbiAgICAgIHByZWZpeCA9ICcnLFxuICAgIH0gPSB7fVxuICApIHtcbiAgICBzdXBlcihvcHRpb25zLCBuZXh0LCBsZWFkaW5nTGluZUJyZWFrcywgbWF4TGluZUxlbmd0aCk7XG4gICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gIH1cbn1cblxuY2xhc3MgVGFibGVTdGFja0l0ZW0gZXh0ZW5kcyBTdGFja0l0ZW0ge1xuICBjb25zdHJ1Y3RvciAobmV4dCA9IG51bGwpIHtcbiAgICBzdXBlcihuZXh0KTtcbiAgICB0aGlzLnJvd3MgPSBbXTtcbiAgICB0aGlzLmlzUHJlID0gbmV4dCAmJiBuZXh0LmlzUHJlO1xuICAgIHRoaXMuaXNOb1dyYXAgPSBuZXh0ICYmIG5leHQuaXNOb1dyYXA7XG4gIH1cbn1cblxuY2xhc3MgVGFibGVSb3dTdGFja0l0ZW0gZXh0ZW5kcyBTdGFja0l0ZW0ge1xuICBjb25zdHJ1Y3RvciAobmV4dCA9IG51bGwpIHtcbiAgICBzdXBlcihuZXh0KTtcbiAgICB0aGlzLmNlbGxzID0gW107XG4gICAgdGhpcy5pc1ByZSA9IG5leHQgJiYgbmV4dC5pc1ByZTtcbiAgICB0aGlzLmlzTm9XcmFwID0gbmV4dCAmJiBuZXh0LmlzTm9XcmFwO1xuICB9XG59XG5cbmNsYXNzIFRhYmxlQ2VsbFN0YWNrSXRlbSBleHRlbmRzIFN0YWNrSXRlbSB7XG4gIGNvbnN0cnVjdG9yIChvcHRpb25zLCBuZXh0ID0gbnVsbCwgbWF4Q29sdW1uV2lkdGggPSB1bmRlZmluZWQpIHtcbiAgICBzdXBlcihuZXh0KTtcbiAgICB0aGlzLmlubGluZVRleHRCdWlsZGVyID0gbmV3IElubGluZVRleHRCdWlsZGVyKG9wdGlvbnMsIG1heENvbHVtbldpZHRoKTtcbiAgICB0aGlzLnJhd1RleHQgPSAnJztcbiAgICB0aGlzLnN0YXNoZWRMaW5lQnJlYWtzID0gMDtcbiAgICB0aGlzLmlzUHJlID0gbmV4dCAmJiBuZXh0LmlzUHJlO1xuICAgIHRoaXMuaXNOb1dyYXAgPSBuZXh0ICYmIG5leHQuaXNOb1dyYXA7XG4gIH1cbn1cblxuY2xhc3MgVHJhbnNmb3JtZXJTdGFja0l0ZW0gZXh0ZW5kcyBTdGFja0l0ZW0ge1xuICBjb25zdHJ1Y3RvciAobmV4dCA9IG51bGwsIHRyYW5zZm9ybSkge1xuICAgIHN1cGVyKG5leHQpO1xuICAgIHRoaXMudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoYXJhY3RlcnNUb0NvZGVzIChzdHIpIHtcbiAgcmV0dXJuIFsuLi5zdHJdXG4gICAgLm1hcChjID0+ICdcXFxcdScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDQsICcwJykpXG4gICAgLmpvaW4oJycpO1xufVxuXG4vKipcbiAqIEhlbHBzIHRvIGhhbmRsZSBIVE1MIHdoaXRlc3BhY2VzLlxuICpcbiAqIEBjbGFzcyBXaGl0ZXNwYWNlUHJvY2Vzc29yXG4gKi9cbmNsYXNzIFdoaXRlc3BhY2VQcm9jZXNzb3Ige1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFdoaXRlc3BhY2VQcm9jZXNzb3IuXG4gICAqXG4gICAqIEBwYXJhbSB7IE9wdGlvbnMgfSBvcHRpb25zICAgIEh0bWxUb1RleHQgb3B0aW9ucy5cbiAgICogQG1lbWJlcm9mIFdoaXRlc3BhY2VQcm9jZXNzb3JcbiAgICovXG4gIGNvbnN0cnVjdG9yIChvcHRpb25zKSB7XG4gICAgdGhpcy53aGl0ZXNwYWNlQ2hhcnMgPSAob3B0aW9ucy5wcmVzZXJ2ZU5ld2xpbmVzKVxuICAgICAgPyBvcHRpb25zLndoaXRlc3BhY2VDaGFyYWN0ZXJzLnJlcGxhY2UoL1xcbi9nLCAnJylcbiAgICAgIDogb3B0aW9ucy53aGl0ZXNwYWNlQ2hhcmFjdGVycztcbiAgICBjb25zdCB3aGl0ZXNwYWNlQ29kZXMgPSBjaGFyYWN0ZXJzVG9Db2Rlcyh0aGlzLndoaXRlc3BhY2VDaGFycyk7XG4gICAgdGhpcy5sZWFkaW5nV2hpdGVzcGFjZVJlID0gbmV3IFJlZ0V4cChgXlske3doaXRlc3BhY2VDb2Rlc31dYCk7XG4gICAgdGhpcy50cmFpbGluZ1doaXRlc3BhY2VSZSA9IG5ldyBSZWdFeHAoYFske3doaXRlc3BhY2VDb2Rlc31dJGApO1xuICAgIHRoaXMuYWxsV2hpdGVzcGFjZU9yRW1wdHlSZSA9IG5ldyBSZWdFeHAoYF5bJHt3aGl0ZXNwYWNlQ29kZXN9XSokYCk7XG4gICAgdGhpcy5uZXdsaW5lT3JOb25XaGl0ZXNwYWNlUmUgPSBuZXcgUmVnRXhwKGAoXFxcXG58W15cXFxcbiR7d2hpdGVzcGFjZUNvZGVzfV0pYCwgJ2cnKTtcbiAgICB0aGlzLm5ld2xpbmVPck5vbk5ld2xpbmVTdHJpbmdSZSA9IG5ldyBSZWdFeHAoYChcXFxcbnxbXlxcXFxuXSspYCwgJ2cnKTtcblxuICAgIGlmIChvcHRpb25zLnByZXNlcnZlTmV3bGluZXMpIHtcblxuICAgICAgY29uc3Qgd29yZE9yTmV3bGluZVJlID0gbmV3IFJlZ0V4cChgXFxcXG58W15cXFxcbiR7d2hpdGVzcGFjZUNvZGVzfV0rYCwgJ2dtJyk7XG5cbiAgICAgIC8qKlxuICAgICAgICogU2hyaW5rIHdoaXRlc3BhY2VzIGFuZCB3cmFwIHRleHQsIGFkZCB0byB0aGUgYnVpbGRlci5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0geyBzdHJpbmcgfSAgICAgICAgICAgICAgICAgIHRleHQgICAgICAgICAgICAgIElucHV0IHRleHQuXG4gICAgICAgKiBAcGFyYW0geyBJbmxpbmVUZXh0QnVpbGRlciB9ICAgICAgIGlubGluZVRleHRCdWlsZGVyIEEgYnVpbGRlciB0byByZWNlaXZlIHByb2Nlc3NlZCB0ZXh0LlxuICAgICAgICogQHBhcmFtIHsgKHN0cjogc3RyaW5nKSA9PiBzdHJpbmcgfSBbIHRyYW5zZm9ybSBdICAgICBBIHRyYW5zZm9ybSB0byBiZSBhcHBsaWVkIHRvIHdvcmRzLlxuICAgICAgICogQHBhcmFtIHsgYm9vbGVhbiB9ICAgICAgICAgICAgICAgICBbbm9XcmFwXSBEb24ndCB3cmFwIHRleHQgZXZlbiBpZiB0aGUgbGluZSBpcyB0b28gbG9uZy5cbiAgICAgICAqL1xuICAgICAgdGhpcy5zaHJpbmtXcmFwQWRkID0gZnVuY3Rpb24gKHRleHQsIGlubGluZVRleHRCdWlsZGVyLCB0cmFuc2Zvcm0gPSAoc3RyID0+IHN0ciksIG5vV3JhcCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghdGV4dCkgeyByZXR1cm47IH1cbiAgICAgICAgY29uc3QgcHJldmlvdXNseVN0YXNoZWRTcGFjZSA9IGlubGluZVRleHRCdWlsZGVyLnN0YXNoZWRTcGFjZTtcbiAgICAgICAgbGV0IGFueU1hdGNoID0gZmFsc2U7XG4gICAgICAgIGxldCBtID0gd29yZE9yTmV3bGluZVJlLmV4ZWModGV4dCk7XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgYW55TWF0Y2ggPSB0cnVlO1xuICAgICAgICAgIGlmIChtWzBdID09PSAnXFxuJykge1xuICAgICAgICAgICAgaW5saW5lVGV4dEJ1aWxkZXIuc3RhcnROZXdMaW5lKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcmV2aW91c2x5U3Rhc2hlZFNwYWNlIHx8IHRoaXMudGVzdExlYWRpbmdXaGl0ZXNwYWNlKHRleHQpKSB7XG4gICAgICAgICAgICBpbmxpbmVUZXh0QnVpbGRlci5wdXNoV29yZCh0cmFuc2Zvcm0obVswXSksIG5vV3JhcCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlubGluZVRleHRCdWlsZGVyLmNvbmNhdFdvcmQodHJhbnNmb3JtKG1bMF0pLCBub1dyYXApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoKG0gPSB3b3JkT3JOZXdsaW5lUmUuZXhlYyh0ZXh0KSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChtWzBdID09PSAnXFxuJykge1xuICAgICAgICAgICAgICBpbmxpbmVUZXh0QnVpbGRlci5zdGFydE5ld0xpbmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlubGluZVRleHRCdWlsZGVyLnB1c2hXb3JkKHRyYW5zZm9ybShtWzBdKSwgbm9XcmFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5saW5lVGV4dEJ1aWxkZXIuc3Rhc2hlZFNwYWNlID0gKHByZXZpb3VzbHlTdGFzaGVkU3BhY2UgJiYgIWFueU1hdGNoKSB8fCAodGhpcy50ZXN0VHJhaWxpbmdXaGl0ZXNwYWNlKHRleHQpKTtcbiAgICAgICAgLy8gTm8gbmVlZCB0byBzdGFzaCBhIHNwYWNlIGluIGNhc2UgbGFzdCBhZGRlZCBpdGVtIHdhcyBhIG5ldyBsaW5lLFxuICAgICAgICAvLyBidXQgdGhhdCB3b24ndCBhZmZlY3QgYW55dGhpbmcgbGF0ZXIgYW55d2F5LlxuICAgICAgfTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGNvbnN0IHdvcmRSZSA9IG5ldyBSZWdFeHAoYFteJHt3aGl0ZXNwYWNlQ29kZXN9XStgLCAnZycpO1xuXG4gICAgICB0aGlzLnNocmlua1dyYXBBZGQgPSBmdW5jdGlvbiAodGV4dCwgaW5saW5lVGV4dEJ1aWxkZXIsIHRyYW5zZm9ybSA9IChzdHIgPT4gc3RyKSwgbm9XcmFwID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCF0ZXh0KSB7IHJldHVybjsgfVxuICAgICAgICBjb25zdCBwcmV2aW91c2x5U3Rhc2hlZFNwYWNlID0gaW5saW5lVGV4dEJ1aWxkZXIuc3Rhc2hlZFNwYWNlO1xuICAgICAgICBsZXQgYW55TWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgbGV0IG0gPSB3b3JkUmUuZXhlYyh0ZXh0KTtcbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICBhbnlNYXRjaCA9IHRydWU7XG4gICAgICAgICAgaWYgKHByZXZpb3VzbHlTdGFzaGVkU3BhY2UgfHwgdGhpcy50ZXN0TGVhZGluZ1doaXRlc3BhY2UodGV4dCkpIHtcbiAgICAgICAgICAgIGlubGluZVRleHRCdWlsZGVyLnB1c2hXb3JkKHRyYW5zZm9ybShtWzBdKSwgbm9XcmFwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5saW5lVGV4dEJ1aWxkZXIuY29uY2F0V29yZCh0cmFuc2Zvcm0obVswXSksIG5vV3JhcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlICgobSA9IHdvcmRSZS5leGVjKHRleHQpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5saW5lVGV4dEJ1aWxkZXIucHVzaFdvcmQodHJhbnNmb3JtKG1bMF0pLCBub1dyYXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbmxpbmVUZXh0QnVpbGRlci5zdGFzaGVkU3BhY2UgPSAocHJldmlvdXNseVN0YXNoZWRTcGFjZSAmJiAhYW55TWF0Y2gpIHx8IHRoaXMudGVzdFRyYWlsaW5nV2hpdGVzcGFjZSh0ZXh0KTtcbiAgICAgIH07XG5cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkIHRleHQgd2l0aCBvbmx5IG1pbmltYWwgcHJvY2Vzc2luZy5cbiAgICogRXZlcnl0aGluZyBiZXR3ZWVuIG5ld2xpbmVzIGNvbnNpZGVyZWQgYSBzaW5nbGUgd29yZC5cbiAgICogTm8gd2hpdGVzcGFjZSBpcyB0cmltbWVkLlxuICAgKiBOb3QgYWZmZWN0ZWQgYnkgcHJlc2VydmVOZXdsaW5lcyBvcHRpb24gLSBgXFxuYCBhbHdheXMgc3RhcnRzIGEgbmV3IGxpbmUuXG4gICAqXG4gICAqIGBub1dyYXBgIGFyZ3VtZW50IGlzIGB0cnVlYCBieSBkZWZhdWx0IC0gdGhpcyB3b24ndCBzdGFydCBhIG5ldyBsaW5lXG4gICAqIGV2ZW4gaWYgdGhlcmUgaXMgbm90IGVub3VnaCBzcGFjZSBsZWZ0IGluIHRoZSBjdXJyZW50IGxpbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7IHN0cmluZyB9ICAgICAgICAgICAgdGV4dCAgICAgICAgICAgICAgSW5wdXQgdGV4dC5cbiAgICogQHBhcmFtIHsgSW5saW5lVGV4dEJ1aWxkZXIgfSBpbmxpbmVUZXh0QnVpbGRlciBBIGJ1aWxkZXIgdG8gcmVjZWl2ZSBwcm9jZXNzZWQgdGV4dC5cbiAgICogQHBhcmFtIHsgYm9vbGVhbiB9ICAgICAgICAgICBbbm9XcmFwXSBEb24ndCB3cmFwIHRleHQgZXZlbiBpZiB0aGUgbGluZSBpcyB0b28gbG9uZy5cbiAgICovXG4gIGFkZExpdGVyYWwgKHRleHQsIGlubGluZVRleHRCdWlsZGVyLCBub1dyYXAgPSB0cnVlKSB7XG4gICAgaWYgKCF0ZXh0KSB7IHJldHVybjsgfVxuICAgIGNvbnN0IHByZXZpb3VzbHlTdGFzaGVkU3BhY2UgPSBpbmxpbmVUZXh0QnVpbGRlci5zdGFzaGVkU3BhY2U7XG4gICAgbGV0IGFueU1hdGNoID0gZmFsc2U7XG4gICAgbGV0IG0gPSB0aGlzLm5ld2xpbmVPck5vbk5ld2xpbmVTdHJpbmdSZS5leGVjKHRleHQpO1xuICAgIGlmIChtKSB7XG4gICAgICBhbnlNYXRjaCA9IHRydWU7XG4gICAgICBpZiAobVswXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgaW5saW5lVGV4dEJ1aWxkZXIuc3RhcnROZXdMaW5lKCk7XG4gICAgICB9IGVsc2UgaWYgKHByZXZpb3VzbHlTdGFzaGVkU3BhY2UpIHtcbiAgICAgICAgaW5saW5lVGV4dEJ1aWxkZXIucHVzaFdvcmQobVswXSwgbm9XcmFwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlubGluZVRleHRCdWlsZGVyLmNvbmNhdFdvcmQobVswXSwgbm9XcmFwKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgobSA9IHRoaXMubmV3bGluZU9yTm9uTmV3bGluZVN0cmluZ1JlLmV4ZWModGV4dCkpICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChtWzBdID09PSAnXFxuJykge1xuICAgICAgICAgIGlubGluZVRleHRCdWlsZGVyLnN0YXJ0TmV3TGluZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlubGluZVRleHRCdWlsZGVyLnB1c2hXb3JkKG1bMF0sIG5vV3JhcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaW5saW5lVGV4dEJ1aWxkZXIuc3Rhc2hlZFNwYWNlID0gKHByZXZpb3VzbHlTdGFzaGVkU3BhY2UgJiYgIWFueU1hdGNoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgdGhlIGdpdmVuIHRleHQgc3RhcnRzIHdpdGggSFRNTCB3aGl0ZXNwYWNlIGNoYXJhY3Rlci5cbiAgICpcbiAgICogQHBhcmFtICAgeyBzdHJpbmcgfSAgdGV4dCAgVGhlIHN0cmluZyB0byB0ZXN0LlxuICAgKiBAcmV0dXJucyB7IGJvb2xlYW4gfVxuICAgKi9cbiAgdGVzdExlYWRpbmdXaGl0ZXNwYWNlICh0ZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMubGVhZGluZ1doaXRlc3BhY2VSZS50ZXN0KHRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlc3Qgd2hldGhlciB0aGUgZ2l2ZW4gdGV4dCBlbmRzIHdpdGggSFRNTCB3aGl0ZXNwYWNlIGNoYXJhY3Rlci5cbiAgICpcbiAgICogQHBhcmFtICAgeyBzdHJpbmcgfSAgdGV4dCAgVGhlIHN0cmluZyB0byB0ZXN0LlxuICAgKiBAcmV0dXJucyB7IGJvb2xlYW4gfVxuICAgKi9cbiAgdGVzdFRyYWlsaW5nV2hpdGVzcGFjZSAodGV4dCkge1xuICAgIHJldHVybiB0aGlzLnRyYWlsaW5nV2hpdGVzcGFjZVJlLnRlc3QodGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogVGVzdCB3aGV0aGVyIHRoZSBnaXZlbiB0ZXh0IGNvbnRhaW5zIGFueSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0gICB7IHN0cmluZyB9ICB0ZXh0ICBUaGUgc3RyaW5nIHRvIHRlc3QuXG4gICAqIEByZXR1cm5zIHsgYm9vbGVhbiB9XG4gICAqL1xuICB0ZXN0Q29udGFpbnNXb3JkcyAodGV4dCkge1xuICAgIHJldHVybiAhdGhpcy5hbGxXaGl0ZXNwYWNlT3JFbXB0eVJlLnRlc3QodGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBudW1iZXIgb2YgbmV3bGluZXMgaWYgdGhlcmUgYXJlIG5vIHdvcmRzLlxuICAgKlxuICAgKiBJZiBhbnkgd29yZCBpcyBmb3VuZCB0aGVuIHJldHVybiB6ZXJvIHJlZ2FyZGxlc3Mgb2YgdGhlIGFjdHVhbCBudW1iZXIgb2YgbmV3bGluZXMuXG4gICAqXG4gICAqIEBwYXJhbSAgIHsgc3RyaW5nIH0gIHRleHQgIElucHV0IHN0cmluZy5cbiAgICogQHJldHVybnMgeyBudW1iZXIgfVxuICAgKi9cbiAgY291bnROZXdsaW5lc05vV29yZHMgKHRleHQpIHtcbiAgICB0aGlzLm5ld2xpbmVPck5vbldoaXRlc3BhY2VSZS5sYXN0SW5kZXggPSAwO1xuICAgIGxldCBjb3VudGVyID0gMDtcbiAgICBsZXQgbWF0Y2g7XG4gICAgd2hpbGUgKChtYXRjaCA9IHRoaXMubmV3bGluZU9yTm9uV2hpdGVzcGFjZVJlLmV4ZWModGV4dCkpICE9PSBudWxsKSB7XG4gICAgICBpZiAobWF0Y2hbMF0gPT09ICdcXG4nKSB7XG4gICAgICAgIGNvdW50ZXIrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY291bnRlcjtcbiAgfVxuXG59XG5cbi8qKlxuICogSGVscHMgdG8gYnVpbGQgdGV4dCBmcm9tIGlubGluZSBhbmQgYmxvY2sgZWxlbWVudHMuXG4gKlxuICogQGNsYXNzIEJsb2NrVGV4dEJ1aWxkZXJcbiAqL1xuY2xhc3MgQmxvY2tUZXh0QnVpbGRlciB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQmxvY2tUZXh0QnVpbGRlci5cbiAgICpcbiAgICogQHBhcmFtIHsgT3B0aW9ucyB9IG9wdGlvbnMgSHRtbFRvVGV4dCBvcHRpb25zLlxuICAgKiBAcGFyYW0geyBpbXBvcnQoJ3NlbGRlcmVlJykuUGlja2VyPERvbU5vZGUsIFRhZ0RlZmluaXRpb24+IH0gcGlja2VyIFNlbGVjdG9ycyBkZWNpc2lvbiB0cmVlIHBpY2tlci5cbiAgICogQHBhcmFtIHsgYW55fSBbbWV0YWRhdGFdIE9wdGlvbmFsIG1ldGFkYXRhIGZvciBIVE1MIGRvY3VtZW50LCBmb3IgdXNlIGluIGZvcm1hdHRlcnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucywgcGlja2VyLCBtZXRhZGF0YSA9IHVuZGVmaW5lZCkge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5waWNrZXIgPSBwaWNrZXI7XG4gICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgIHRoaXMud2hpdGVzcGFjZVByb2Nlc3NvciA9IG5ldyBXaGl0ZXNwYWNlUHJvY2Vzc29yKG9wdGlvbnMpO1xuICAgIC8qKiBAdHlwZSB7IFN0YWNrSXRlbSB9ICovXG4gICAgdGhpcy5fc3RhY2tJdGVtID0gbmV3IEJsb2NrU3RhY2tJdGVtKG9wdGlvbnMpO1xuICAgIC8qKiBAdHlwZSB7IFRyYW5zZm9ybWVyU3RhY2tJdGVtIH0gKi9cbiAgICB0aGlzLl93b3JkVHJhbnNmb3JtZXIgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogUHV0IGEgd29yZC1ieS13b3JkIHRyYW5zZm9ybSBmdW5jdGlvbiBvbnRvIHRoZSB0cmFuc2Zvcm1hdGlvbnMgc3RhY2suXG4gICAqXG4gICAqIE1haW5seSB1c2VkIGZvciB1cHBlcmNhc2luZy4gQ2FuIGJlIGJ5cGFzc2VkIHRvIGFkZCB1bmZvcm1hdHRlZCB0ZXh0IHN1Y2ggYXMgVVJMcy5cbiAgICpcbiAgICogV29yZCB0cmFuc2Zvcm1hdGlvbnMgYXBwbGllZCBiZWZvcmUgd3JhcHBpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7IChzdHI6IHN0cmluZykgPT4gc3RyaW5nIH0gd29yZFRyYW5zZm9ybSBXb3JkIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9uLlxuICAgKi9cbiAgcHVzaFdvcmRUcmFuc2Zvcm0gKHdvcmRUcmFuc2Zvcm0pIHtcbiAgICB0aGlzLl93b3JkVHJhbnNmb3JtZXIgPSBuZXcgVHJhbnNmb3JtZXJTdGFja0l0ZW0odGhpcy5fd29yZFRyYW5zZm9ybWVyLCB3b3JkVHJhbnNmb3JtKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBmdW5jdGlvbiBmcm9tIHRoZSB3b3JkIHRyYW5zZm9ybWF0aW9ucyBzdGFjay5cbiAgICpcbiAgICogQHJldHVybnMgeyAoc3RyOiBzdHJpbmcpID0+IHN0cmluZyB9IEEgZnVuY3Rpb24gdGhhdCB3YXMgcmVtb3ZlZC5cbiAgICovXG4gIHBvcFdvcmRUcmFuc2Zvcm0gKCkge1xuICAgIGlmICghdGhpcy5fd29yZFRyYW5zZm9ybWVyKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgICBjb25zdCB0cmFuc2Zvcm0gPSB0aGlzLl93b3JkVHJhbnNmb3JtZXIudHJhbnNmb3JtO1xuICAgIHRoaXMuX3dvcmRUcmFuc2Zvcm1lciA9IHRoaXMuX3dvcmRUcmFuc2Zvcm1lci5uZXh0O1xuICAgIHJldHVybiB0cmFuc2Zvcm07XG4gIH1cblxuICAvKipcbiAgICogSWdub3JlIHdvcmR3cmFwIG9wdGlvbiBpbiBmb2xsb3d1cCBpbmxpbmUgYWRkaXRpb25zIGFuZCBkaXNhYmxlIGF1dG9tYXRpYyB3cmFwcGluZy5cbiAgICovXG4gIHN0YXJ0Tm9XcmFwICgpIHtcbiAgICB0aGlzLl9zdGFja0l0ZW0uaXNOb1dyYXAgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhdXRvbWF0aWMgd3JhcHBpbmcgdG8gYmVoYXZpb3IgZGVmaW5lZCBieSBvcHRpb25zLlxuICAgKi9cbiAgc3RvcE5vV3JhcCAoKSB7XG4gICAgdGhpcy5fc3RhY2tJdGVtLmlzTm9XcmFwID0gZmFsc2U7XG4gIH1cblxuICAvKiogQHJldHVybnMgeyAoc3RyOiBzdHJpbmcpID0+IHN0cmluZyB9ICovXG4gIF9nZXRDb21iaW5lZFdvcmRUcmFuc2Zvcm1lciAoKSB7XG4gICAgY29uc3Qgd3QgPSAodGhpcy5fd29yZFRyYW5zZm9ybWVyKVxuICAgICAgPyAoKHN0cikgPT4gYXBwbHlUcmFuc2Zvcm1lcihzdHIsIHRoaXMuX3dvcmRUcmFuc2Zvcm1lcikpXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBjZSA9IHRoaXMub3B0aW9ucy5lbmNvZGVDaGFyYWN0ZXJzO1xuICAgIHJldHVybiAod3QpXG4gICAgICA/ICgoY2UpID8gKHN0cikgPT4gY2Uod3Qoc3RyKSkgOiB3dClcbiAgICAgIDogY2U7XG4gIH1cblxuICBfcG9wU3RhY2tJdGVtICgpIHtcbiAgICBjb25zdCBpdGVtID0gdGhpcy5fc3RhY2tJdGVtO1xuICAgIHRoaXMuX3N0YWNrSXRlbSA9IGl0ZW0ubmV4dDtcbiAgICByZXR1cm4gaXRlbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBsaW5lIGJyZWFrIGludG8gY3VycmVudGx5IGJ1aWx0IGJsb2NrLlxuICAgKi9cbiAgYWRkTGluZUJyZWFrICgpIHtcbiAgICBpZiAoIShcbiAgICAgIHRoaXMuX3N0YWNrSXRlbSBpbnN0YW5jZW9mIEJsb2NrU3RhY2tJdGVtXG4gICAgICB8fCB0aGlzLl9zdGFja0l0ZW0gaW5zdGFuY2VvZiBMaXN0SXRlbVN0YWNrSXRlbVxuICAgICAgfHwgdGhpcy5fc3RhY2tJdGVtIGluc3RhbmNlb2YgVGFibGVDZWxsU3RhY2tJdGVtXG4gICAgKSkgeyByZXR1cm47IH1cbiAgICBpZiAodGhpcy5fc3RhY2tJdGVtLmlzUHJlKSB7XG4gICAgICB0aGlzLl9zdGFja0l0ZW0ucmF3VGV4dCArPSAnXFxuJztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc3RhY2tJdGVtLmlubGluZVRleHRCdWlsZGVyLnN0YXJ0TmV3TGluZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBbGxvdyB0byBicmVhayBsaW5lIGluIGNhc2UgZGlyZWN0bHkgZm9sbG93aW5nIHRleHQgd2lsbCBub3QgZml0LlxuICAgKi9cbiAgYWRkV29yZEJyZWFrT3Bwb3J0dW5pdHkgKCkge1xuICAgIGlmIChcbiAgICAgIHRoaXMuX3N0YWNrSXRlbSBpbnN0YW5jZW9mIEJsb2NrU3RhY2tJdGVtXG4gICAgICB8fCB0aGlzLl9zdGFja0l0ZW0gaW5zdGFuY2VvZiBMaXN0SXRlbVN0YWNrSXRlbVxuICAgICAgfHwgdGhpcy5fc3RhY2tJdGVtIGluc3RhbmNlb2YgVGFibGVDZWxsU3RhY2tJdGVtXG4gICAgKSB7XG4gICAgICB0aGlzLl9zdGFja0l0ZW0uaW5saW5lVGV4dEJ1aWxkZXIud29yZEJyZWFrT3Bwb3J0dW5pdHkgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBub2RlIGlubGluZSBpbnRvIHRoZSBjdXJyZW50bHkgYnVpbHQgYmxvY2suXG4gICAqXG4gICAqIEBwYXJhbSB7IHN0cmluZyB9IHN0clxuICAgKiBUZXh0IGNvbnRlbnQgb2YgYSBub2RlIHRvIGFkZC5cbiAgICpcbiAgICogQHBhcmFtIHsgb2JqZWN0IH0gW3BhcmFtMV1cbiAgICogT2JqZWN0IGhvbGRpbmcgdGhlIHBhcmFtZXRlcnMgb2YgdGhlIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHsgYm9vbGVhbiB9IFtwYXJhbTEubm9Xb3JkVHJhbnNmb3JtXVxuICAgKiBJZ25vcmUgd29yZCB0cmFuc2Zvcm1lcnMgaWYgdGhlcmUgYXJlIGFueS5cbiAgICogRG9uJ3QgZW5jb2RlIGNoYXJhY3RlcnMgYXMgd2VsbC5cbiAgICogKFVzZSB0aGlzIGZvciB0aGluZ3MgbGlrZSBVUkwgYWRkcmVzc2VzKS5cbiAgICovXG4gIGFkZElubGluZSAoc3RyLCB7IG5vV29yZFRyYW5zZm9ybSA9IGZhbHNlIH0gPSB7fSkge1xuICAgIGlmICghKFxuICAgICAgdGhpcy5fc3RhY2tJdGVtIGluc3RhbmNlb2YgQmxvY2tTdGFja0l0ZW1cbiAgICAgIHx8IHRoaXMuX3N0YWNrSXRlbSBpbnN0YW5jZW9mIExpc3RJdGVtU3RhY2tJdGVtXG4gICAgICB8fCB0aGlzLl9zdGFja0l0ZW0gaW5zdGFuY2VvZiBUYWJsZUNlbGxTdGFja0l0ZW1cbiAgICApKSB7IHJldHVybjsgfVxuXG4gICAgaWYgKHRoaXMuX3N0YWNrSXRlbS5pc1ByZSkge1xuICAgICAgdGhpcy5fc3RhY2tJdGVtLnJhd1RleHQgKz0gc3RyO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHN0ci5sZW5ndGggPT09IDAgfHwgLy8gZW1wdHkgc3RyaW5nXG4gICAgICAoXG4gICAgICAgIHRoaXMuX3N0YWNrSXRlbS5zdGFzaGVkTGluZUJyZWFrcyAmJiAvLyBzdGFzaGVkIGxpbmVicmVha3MgbWFrZSB3aGl0ZXNwYWNlIGlycmVsZXZhbnRcbiAgICAgICAgIXRoaXMud2hpdGVzcGFjZVByb2Nlc3Nvci50ZXN0Q29udGFpbnNXb3JkcyhzdHIpIC8vIG5vIHdvcmRzIHRvIGFkZFxuICAgICAgKVxuICAgICkgeyByZXR1cm47IH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMucHJlc2VydmVOZXdsaW5lcykge1xuICAgICAgY29uc3QgbmV3bGluZXNOdW1iZXIgPSB0aGlzLndoaXRlc3BhY2VQcm9jZXNzb3IuY291bnROZXdsaW5lc05vV29yZHMoc3RyKTtcbiAgICAgIGlmIChuZXdsaW5lc051bWJlciA+IDApIHtcbiAgICAgICAgdGhpcy5fc3RhY2tJdGVtLmlubGluZVRleHRCdWlsZGVyLnN0YXJ0TmV3TGluZShuZXdsaW5lc051bWJlcik7XG4gICAgICAgIC8vIGtlZXAgc3Rhc2hlZExpbmVCcmVha3MgdW5jaGFuZ2VkXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc3RhY2tJdGVtLnN0YXNoZWRMaW5lQnJlYWtzKSB7XG4gICAgICB0aGlzLl9zdGFja0l0ZW0uaW5saW5lVGV4dEJ1aWxkZXIuc3RhcnROZXdMaW5lKHRoaXMuX3N0YWNrSXRlbS5zdGFzaGVkTGluZUJyZWFrcyk7XG4gICAgfVxuICAgIHRoaXMud2hpdGVzcGFjZVByb2Nlc3Nvci5zaHJpbmtXcmFwQWRkKFxuICAgICAgc3RyLFxuICAgICAgdGhpcy5fc3RhY2tJdGVtLmlubGluZVRleHRCdWlsZGVyLFxuICAgICAgKG5vV29yZFRyYW5zZm9ybSkgPyB1bmRlZmluZWQgOiB0aGlzLl9nZXRDb21iaW5lZFdvcmRUcmFuc2Zvcm1lcigpLFxuICAgICAgdGhpcy5fc3RhY2tJdGVtLmlzTm9XcmFwXG4gICAgKTtcbiAgICB0aGlzLl9zdGFja0l0ZW0uc3Rhc2hlZExpbmVCcmVha3MgPSAwOyAvLyBpbmxpbmUgdGV4dCBkb2Vzbid0IGludHJvZHVjZSBsaW5lIGJyZWFrc1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHN0cmluZyBpbmxpbmUgaW50byB0aGUgY3VycmVudGx5IGJ1aWx0IGJsb2NrLlxuICAgKlxuICAgKiBVc2UgdGhpcyBmb3IgbWFya3VwIGVsZW1lbnRzIHRoYXQgZG9uJ3QgaGF2ZSB0byBhZGhlcmVcbiAgICogdG8gdGV4dCBsYXlvdXQgcnVsZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7IHN0cmluZyB9IHN0ciBUZXh0IHRvIGFkZC5cbiAgICovXG4gIGFkZExpdGVyYWwgKHN0cikge1xuICAgIGlmICghKFxuICAgICAgdGhpcy5fc3RhY2tJdGVtIGluc3RhbmNlb2YgQmxvY2tTdGFja0l0ZW1cbiAgICAgIHx8IHRoaXMuX3N0YWNrSXRlbSBpbnN0YW5jZW9mIExpc3RJdGVtU3RhY2tJdGVtXG4gICAgICB8fCB0aGlzLl9zdGFja0l0ZW0gaW5zdGFuY2VvZiBUYWJsZUNlbGxTdGFja0l0ZW1cbiAgICApKSB7IHJldHVybjsgfVxuXG4gICAgaWYgKHN0ci5sZW5ndGggPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgICBpZiAodGhpcy5fc3RhY2tJdGVtLmlzUHJlKSB7XG4gICAgICB0aGlzLl9zdGFja0l0ZW0ucmF3VGV4dCArPSBzdHI7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3N0YWNrSXRlbS5zdGFzaGVkTGluZUJyZWFrcykge1xuICAgICAgdGhpcy5fc3RhY2tJdGVtLmlubGluZVRleHRCdWlsZGVyLnN0YXJ0TmV3TGluZSh0aGlzLl9zdGFja0l0ZW0uc3Rhc2hlZExpbmVCcmVha3MpO1xuICAgIH1cbiAgICB0aGlzLndoaXRlc3BhY2VQcm9jZXNzb3IuYWRkTGl0ZXJhbChcbiAgICAgIHN0cixcbiAgICAgIHRoaXMuX3N0YWNrSXRlbS5pbmxpbmVUZXh0QnVpbGRlcixcbiAgICAgIHRoaXMuX3N0YWNrSXRlbS5pc05vV3JhcFxuICAgICk7XG4gICAgdGhpcy5fc3RhY2tJdGVtLnN0YXNoZWRMaW5lQnJlYWtzID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBidWlsZGluZyBhIG5ldyBibG9jay5cbiAgICpcbiAgICogQHBhcmFtIHsgb2JqZWN0IH0gW3BhcmFtMF1cbiAgICogT2JqZWN0IGhvbGRpbmcgdGhlIHBhcmFtZXRlcnMgb2YgdGhlIGJsb2NrLlxuICAgKlxuICAgKiBAcGFyYW0geyBudW1iZXIgfSBbcGFyYW0wLmxlYWRpbmdMaW5lQnJlYWtzXVxuICAgKiBUaGlzIGJsb2NrIHNob3VsZCBoYXZlIGF0IGxlYXN0IHRoaXMgbnVtYmVyIG9mIGxpbmUgYnJlYWtzIHRvIHNlcGFyYXRlIGl0IGZyb20gYW55IHByZWNlZGluZyBibG9jay5cbiAgICpcbiAgICogQHBhcmFtIHsgbnVtYmVyIH0gIFtwYXJhbTAucmVzZXJ2ZWRMaW5lTGVuZ3RoXVxuICAgKiBSZXNlcnZlIHRoaXMgbnVtYmVyIG9mIGNoYXJhY3RlcnMgb24gZWFjaCBsaW5lIGZvciBibG9jayBtYXJrdXAuXG4gICAqXG4gICAqIEBwYXJhbSB7IGJvb2xlYW4gfSBbcGFyYW0wLmlzUHJlXVxuICAgKiBTaG91bGQgSFRNTCB3aGl0ZXNwYWNlIGJlIHByZXNlcnZlZCBpbnNpZGUgdGhpcyBibG9jay5cbiAgICovXG4gIG9wZW5CbG9jayAoeyBsZWFkaW5nTGluZUJyZWFrcyA9IDEsIHJlc2VydmVkTGluZUxlbmd0aCA9IDAsIGlzUHJlID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgY29uc3QgbWF4TGluZUxlbmd0aCA9IE1hdGgubWF4KDIwLCB0aGlzLl9zdGFja0l0ZW0uaW5saW5lVGV4dEJ1aWxkZXIubWF4TGluZUxlbmd0aCAtIHJlc2VydmVkTGluZUxlbmd0aCk7XG4gICAgdGhpcy5fc3RhY2tJdGVtID0gbmV3IEJsb2NrU3RhY2tJdGVtKFxuICAgICAgdGhpcy5vcHRpb25zLFxuICAgICAgdGhpcy5fc3RhY2tJdGVtLFxuICAgICAgbGVhZGluZ0xpbmVCcmVha3MsXG4gICAgICBtYXhMaW5lTGVuZ3RoXG4gICAgKTtcbiAgICBpZiAoaXNQcmUpIHsgdGhpcy5fc3RhY2tJdGVtLmlzUHJlID0gdHJ1ZTsgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZpbmFsaXplIGN1cnJlbnRseSBidWlsdCBibG9jaywgYWRkIGl0J3MgY29udGVudCB0byB0aGUgcGFyZW50IGJsb2NrLlxuICAgKlxuICAgKiBAcGFyYW0geyBvYmplY3QgfSBbcGFyYW0wXVxuICAgKiBPYmplY3QgaG9sZGluZyB0aGUgcGFyYW1ldGVycyBvZiB0aGUgYmxvY2suXG4gICAqXG4gICAqIEBwYXJhbSB7IG51bWJlciB9IFtwYXJhbTAudHJhaWxpbmdMaW5lQnJlYWtzXVxuICAgKiBUaGlzIGJsb2NrIHNob3VsZCBoYXZlIGF0IGxlYXN0IHRoaXMgbnVtYmVyIG9mIGxpbmUgYnJlYWtzIHRvIHNlcGFyYXRlIGl0IGZyb20gYW55IGZvbGxvd2luZyBibG9jay5cbiAgICpcbiAgICogQHBhcmFtIHsgKHN0cjogc3RyaW5nKSA9PiBzdHJpbmcgfSBbcGFyYW0wLmJsb2NrVHJhbnNmb3JtXVxuICAgKiBBIGZ1bmN0aW9uIHRvIHRyYW5zZm9ybSB0aGUgYmxvY2sgdGV4dCBiZWZvcmUgYWRkaW5nIHRvIHRoZSBwYXJlbnQgYmxvY2suXG4gICAqIFRoaXMgaGFwcGVucyBhZnRlciB3b3JkIHdyYXAgYW5kIHNob3VsZCBiZSB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggcmVzZXJ2ZWQgbGluZSBsZW5ndGhcbiAgICogaW4gb3JkZXIgdG8ga2VlcCBsaW5lIGxlbmd0aHMgY29ycmVjdC5cbiAgICogVXNlZCBmb3Igd2hvbGUgYmxvY2sgbWFya3VwLlxuICAgKi9cbiAgY2xvc2VCbG9jayAoeyB0cmFpbGluZ0xpbmVCcmVha3MgPSAxLCBibG9ja1RyYW5zZm9ybSA9IHVuZGVmaW5lZCB9ID0ge30pIHtcbiAgICBjb25zdCBibG9jayA9IHRoaXMuX3BvcFN0YWNrSXRlbSgpO1xuICAgIGNvbnN0IGJsb2NrVGV4dCA9IChibG9ja1RyYW5zZm9ybSkgPyBibG9ja1RyYW5zZm9ybShnZXRUZXh0KGJsb2NrKSkgOiBnZXRUZXh0KGJsb2NrKTtcbiAgICBhZGRUZXh0KHRoaXMuX3N0YWNrSXRlbSwgYmxvY2tUZXh0LCBibG9jay5sZWFkaW5nTGluZUJyZWFrcywgTWF0aC5tYXgoYmxvY2suc3Rhc2hlZExpbmVCcmVha3MsIHRyYWlsaW5nTGluZUJyZWFrcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGJ1aWxkaW5nIGEgbmV3IGxpc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7IG9iamVjdCB9IFtwYXJhbTBdXG4gICAqIE9iamVjdCBob2xkaW5nIHRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBsaXN0LlxuICAgKlxuICAgKiBAcGFyYW0geyBudW1iZXIgfSBbcGFyYW0wLm1heFByZWZpeExlbmd0aF1cbiAgICogTGVuZ3RoIG9mIHRoZSBsb25nZXN0IGxpc3QgaXRlbSBwcmVmaXguXG4gICAqIElmIG5vdCBzdXBwbGllZCBvciB0b28gc21hbGwgdGhlbiBsaXN0IGl0ZW1zIHdvbid0IGJlIGFsaWduZWQgcHJvcGVybHkuXG4gICAqXG4gICAqIEBwYXJhbSB7ICdsZWZ0JyB8ICdyaWdodCcgfSBbcGFyYW0wLnByZWZpeEFsaWduXVxuICAgKiBTcGVjaWZ5IGhvdyBwcmVmaXhlcyBvZiBkaWZmZXJlbnQgbGVuZ3RocyBoYXZlIHRvIGJlIGFsaWduZWRcbiAgICogd2l0aGluIGEgY29sdW1uLlxuICAgKlxuICAgKiBAcGFyYW0geyBudW1iZXIgfSBbcGFyYW0wLmludGVyUm93TGluZUJyZWFrc11cbiAgICogTWluaW11bSBudW1iZXIgb2YgbGluZSBicmVha3MgYmV0d2VlbiBsaXN0IGl0ZW1zLlxuICAgKlxuICAgKiBAcGFyYW0geyBudW1iZXIgfSBbcGFyYW0wLmxlYWRpbmdMaW5lQnJlYWtzXVxuICAgKiBUaGlzIGxpc3Qgc2hvdWxkIGhhdmUgYXQgbGVhc3QgdGhpcyBudW1iZXIgb2YgbGluZSBicmVha3MgdG8gc2VwYXJhdGUgaXQgZnJvbSBhbnkgcHJlY2VkaW5nIGJsb2NrLlxuICAgKi9cbiAgb3Blbkxpc3QgKHsgbWF4UHJlZml4TGVuZ3RoID0gMCwgcHJlZml4QWxpZ24gPSAnbGVmdCcsIGludGVyUm93TGluZUJyZWFrcyA9IDEsIGxlYWRpbmdMaW5lQnJlYWtzID0gMiB9ID0ge30pIHtcbiAgICB0aGlzLl9zdGFja0l0ZW0gPSBuZXcgTGlzdFN0YWNrSXRlbSh0aGlzLm9wdGlvbnMsIHRoaXMuX3N0YWNrSXRlbSwge1xuICAgICAgaW50ZXJSb3dMaW5lQnJlYWtzOiBpbnRlclJvd0xpbmVCcmVha3MsXG4gICAgICBsZWFkaW5nTGluZUJyZWFrczogbGVhZGluZ0xpbmVCcmVha3MsXG4gICAgICBtYXhMaW5lTGVuZ3RoOiB0aGlzLl9zdGFja0l0ZW0uaW5saW5lVGV4dEJ1aWxkZXIubWF4TGluZUxlbmd0aCxcbiAgICAgIG1heFByZWZpeExlbmd0aDogbWF4UHJlZml4TGVuZ3RoLFxuICAgICAgcHJlZml4QWxpZ246IHByZWZpeEFsaWduXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgYnVpbGRpbmcgYSBuZXcgbGlzdCBpdGVtLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW0wXG4gICAqIE9iamVjdCBob2xkaW5nIHRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBsaXN0IGl0ZW0uXG4gICAqXG4gICAqIEBwYXJhbSB7IHN0cmluZyB9IFtwYXJhbTAucHJlZml4XVxuICAgKiBQcmVmaXggZm9yIHRoaXMgbGlzdCBpdGVtIChpdGVtIG51bWJlciwgYnVsbGV0IHBvaW50LCBldGMpLlxuICAgKi9cbiAgb3Blbkxpc3RJdGVtICh7IHByZWZpeCA9ICcnIH0gPSB7fSkge1xuICAgIGlmICghKHRoaXMuX3N0YWNrSXRlbSBpbnN0YW5jZW9mIExpc3RTdGFja0l0ZW0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgYWRkIGEgbGlzdCBpdGVtIHRvIHNvbWV0aGluZyB0aGF0IGlzIG5vdCBhIGxpc3QhIENoZWNrIHRoZSBmb3JtYXR0ZXIuJyk7XG4gICAgfVxuICAgIGNvbnN0IGxpc3QgPSB0aGlzLl9zdGFja0l0ZW07XG4gICAgY29uc3QgcHJlZml4TGVuZ3RoID0gTWF0aC5tYXgocHJlZml4Lmxlbmd0aCwgbGlzdC5tYXhQcmVmaXhMZW5ndGgpO1xuICAgIGNvbnN0IG1heExpbmVMZW5ndGggPSBNYXRoLm1heCgyMCwgbGlzdC5pbmxpbmVUZXh0QnVpbGRlci5tYXhMaW5lTGVuZ3RoIC0gcHJlZml4TGVuZ3RoKTtcbiAgICB0aGlzLl9zdGFja0l0ZW0gPSBuZXcgTGlzdEl0ZW1TdGFja0l0ZW0odGhpcy5vcHRpb25zLCBsaXN0LCB7XG4gICAgICBwcmVmaXg6IHByZWZpeCxcbiAgICAgIG1heExpbmVMZW5ndGg6IG1heExpbmVMZW5ndGgsXG4gICAgICBsZWFkaW5nTGluZUJyZWFrczogbGlzdC5pbnRlclJvd0xpbmVCcmVha3NcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5hbGl6ZSBjdXJyZW50bHkgYnVpbHQgbGlzdCBpdGVtLCBhZGQgaXQncyBjb250ZW50IHRvIHRoZSBwYXJlbnQgbGlzdC5cbiAgICovXG4gIGNsb3NlTGlzdEl0ZW0gKCkge1xuICAgIGNvbnN0IGxpc3RJdGVtID0gdGhpcy5fcG9wU3RhY2tJdGVtKCk7XG4gICAgY29uc3QgbGlzdCA9IGxpc3RJdGVtLm5leHQ7XG5cbiAgICBjb25zdCBwcmVmaXhMZW5ndGggPSBNYXRoLm1heChsaXN0SXRlbS5wcmVmaXgubGVuZ3RoLCBsaXN0Lm1heFByZWZpeExlbmd0aCk7XG4gICAgY29uc3Qgc3BhY2luZyA9ICdcXG4nICsgJyAnLnJlcGVhdChwcmVmaXhMZW5ndGgpO1xuICAgIGNvbnN0IHByZWZpeCA9IChsaXN0LnByZWZpeEFsaWduID09PSAncmlnaHQnKVxuICAgICAgPyBsaXN0SXRlbS5wcmVmaXgucGFkU3RhcnQocHJlZml4TGVuZ3RoKVxuICAgICAgOiBsaXN0SXRlbS5wcmVmaXgucGFkRW5kKHByZWZpeExlbmd0aCk7XG4gICAgY29uc3QgdGV4dCA9IHByZWZpeCArIGdldFRleHQobGlzdEl0ZW0pLnJlcGxhY2UoL1xcbi9nLCBzcGFjaW5nKTtcblxuICAgIGFkZFRleHQoXG4gICAgICBsaXN0LFxuICAgICAgdGV4dCxcbiAgICAgIGxpc3RJdGVtLmxlYWRpbmdMaW5lQnJlYWtzLFxuICAgICAgTWF0aC5tYXgobGlzdEl0ZW0uc3Rhc2hlZExpbmVCcmVha3MsIGxpc3QuaW50ZXJSb3dMaW5lQnJlYWtzKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRmluYWxpemUgY3VycmVudGx5IGJ1aWx0IGxpc3QsIGFkZCBpdCdzIGNvbnRlbnQgdG8gdGhlIHBhcmVudCBibG9jay5cbiAgICpcbiAgICogQHBhcmFtIHsgb2JqZWN0IH0gcGFyYW0wXG4gICAqIE9iamVjdCBob2xkaW5nIHRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBsaXN0LlxuICAgKlxuICAgKiBAcGFyYW0geyBudW1iZXIgfSBbcGFyYW0wLnRyYWlsaW5nTGluZUJyZWFrc11cbiAgICogVGhpcyBsaXN0IHNob3VsZCBoYXZlIGF0IGxlYXN0IHRoaXMgbnVtYmVyIG9mIGxpbmUgYnJlYWtzIHRvIHNlcGFyYXRlIGl0IGZyb20gYW55IGZvbGxvd2luZyBibG9jay5cbiAgICovXG4gIGNsb3NlTGlzdCAoeyB0cmFpbGluZ0xpbmVCcmVha3MgPSAyIH0gPSB7fSkge1xuICAgIGNvbnN0IGxpc3QgPSB0aGlzLl9wb3BTdGFja0l0ZW0oKTtcbiAgICBjb25zdCB0ZXh0ID0gZ2V0VGV4dChsaXN0KTtcbiAgICBpZiAodGV4dCkge1xuICAgICAgYWRkVGV4dCh0aGlzLl9zdGFja0l0ZW0sIHRleHQsIGxpc3QubGVhZGluZ0xpbmVCcmVha3MsIHRyYWlsaW5nTGluZUJyZWFrcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGJ1aWxkaW5nIGEgdGFibGUuXG4gICAqL1xuICBvcGVuVGFibGUgKCkge1xuICAgIHRoaXMuX3N0YWNrSXRlbSA9IG5ldyBUYWJsZVN0YWNrSXRlbSh0aGlzLl9zdGFja0l0ZW0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGJ1aWxkaW5nIGEgdGFibGUgcm93LlxuICAgKi9cbiAgb3BlblRhYmxlUm93ICgpIHtcbiAgICBpZiAoISh0aGlzLl9zdGFja0l0ZW0gaW5zdGFuY2VvZiBUYWJsZVN0YWNrSXRlbSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBhZGQgYSB0YWJsZSByb3cgdG8gc29tZXRoaW5nIHRoYXQgaXMgbm90IGEgdGFibGUhIENoZWNrIHRoZSBmb3JtYXR0ZXIuJyk7XG4gICAgfVxuICAgIHRoaXMuX3N0YWNrSXRlbSA9IG5ldyBUYWJsZVJvd1N0YWNrSXRlbSh0aGlzLl9zdGFja0l0ZW0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGJ1aWxkaW5nIGEgdGFibGUgY2VsbC5cbiAgICpcbiAgICogQHBhcmFtIHsgb2JqZWN0IH0gW3BhcmFtMF1cbiAgICogT2JqZWN0IGhvbGRpbmcgdGhlIHBhcmFtZXRlcnMgb2YgdGhlIGNlbGwuXG4gICAqXG4gICAqIEBwYXJhbSB7IG51bWJlciB9IFtwYXJhbTAubWF4Q29sdW1uV2lkdGhdXG4gICAqIFdyYXAgY2VsbCBjb250ZW50IHRvIHRoaXMgd2lkdGguIEZhbGwgYmFjayB0byBnbG9iYWwgd29yZHdyYXAgdmFsdWUgaWYgdW5kZWZpbmVkLlxuICAgKi9cbiAgb3BlblRhYmxlQ2VsbCAoeyBtYXhDb2x1bW5XaWR0aCA9IHVuZGVmaW5lZCB9ID0ge30pIHtcbiAgICBpZiAoISh0aGlzLl9zdGFja0l0ZW0gaW5zdGFuY2VvZiBUYWJsZVJvd1N0YWNrSXRlbSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBhZGQgYSB0YWJsZSBjZWxsIHRvIHNvbWV0aGluZyB0aGF0IGlzIG5vdCBhIHRhYmxlIHJvdyEgQ2hlY2sgdGhlIGZvcm1hdHRlci4nKTtcbiAgICB9XG4gICAgdGhpcy5fc3RhY2tJdGVtID0gbmV3IFRhYmxlQ2VsbFN0YWNrSXRlbSh0aGlzLm9wdGlvbnMsIHRoaXMuX3N0YWNrSXRlbSwgbWF4Q29sdW1uV2lkdGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmFsaXplIGN1cnJlbnRseSBidWlsdCB0YWJsZSBjZWxsIGFuZCBhZGQgaXQgdG8gcGFyZW50IHRhYmxlIHJvdydzIGNlbGxzLlxuICAgKlxuICAgKiBAcGFyYW0geyBvYmplY3QgfSBbcGFyYW0wXVxuICAgKiBPYmplY3QgaG9sZGluZyB0aGUgcGFyYW1ldGVycyBvZiB0aGUgY2VsbC5cbiAgICpcbiAgICogQHBhcmFtIHsgbnVtYmVyIH0gW3BhcmFtMC5jb2xzcGFuXSBIb3cgbWFueSBjb2x1bW5zIHRoaXMgY2VsbCBzaG91bGQgb2NjdXB5LlxuICAgKiBAcGFyYW0geyBudW1iZXIgfSBbcGFyYW0wLnJvd3NwYW5dIEhvdyBtYW55IHJvd3MgdGhpcyBjZWxsIHNob3VsZCBvY2N1cHkuXG4gICAqL1xuICBjbG9zZVRhYmxlQ2VsbCAoeyBjb2xzcGFuID0gMSwgcm93c3BhbiA9IDEgfSA9IHt9KSB7XG4gICAgY29uc3QgY2VsbCA9IHRoaXMuX3BvcFN0YWNrSXRlbSgpO1xuICAgIGNvbnN0IHRleHQgPSB0cmltQ2hhcmFjdGVyKGdldFRleHQoY2VsbCksICdcXG4nKTtcbiAgICBjZWxsLm5leHQuY2VsbHMucHVzaCh7IGNvbHNwYW46IGNvbHNwYW4sIHJvd3NwYW46IHJvd3NwYW4sIHRleHQ6IHRleHQgfSk7XG4gIH1cblxuICAvKipcbiAgICogRmluYWxpemUgY3VycmVudGx5IGJ1aWx0IHRhYmxlIHJvdyBhbmQgYWRkIGl0IHRvIHBhcmVudCB0YWJsZSdzIHJvd3MuXG4gICAqL1xuICBjbG9zZVRhYmxlUm93ICgpIHtcbiAgICBjb25zdCByb3cgPSB0aGlzLl9wb3BTdGFja0l0ZW0oKTtcbiAgICByb3cubmV4dC5yb3dzLnB1c2gocm93LmNlbGxzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5hbGl6ZSBjdXJyZW50bHkgYnVpbHQgdGFibGUgYW5kIGFkZCB0aGUgcmVuZGVyZWQgdGV4dCB0byB0aGUgcGFyZW50IGJsb2NrLlxuICAgKlxuICAgKiBAcGFyYW0geyBvYmplY3QgfSBwYXJhbTBcbiAgICogT2JqZWN0IGhvbGRpbmcgdGhlIHBhcmFtZXRlcnMgb2YgdGhlIHRhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0geyBUYWJsZVByaW50ZXIgfSBwYXJhbTAudGFibGVUb1N0cmluZ1xuICAgKiBBIGZ1bmN0aW9uIHRvIGNvbnZlcnQgYSB0YWJsZSBvZiBzdHJpbmdpZmllZCBjZWxscyBpbnRvIGEgY29tcGxldGUgdGFibGUuXG4gICAqXG4gICAqIEBwYXJhbSB7IG51bWJlciB9IFtwYXJhbTAubGVhZGluZ0xpbmVCcmVha3NdXG4gICAqIFRoaXMgdGFibGUgc2hvdWxkIGhhdmUgYXQgbGVhc3QgdGhpcyBudW1iZXIgb2YgbGluZSBicmVha3MgdG8gc2VwYXJhdGUgaWYgZnJvbSBhbnkgcHJlY2VkaW5nIGJsb2NrLlxuICAgKlxuICAgKiBAcGFyYW0geyBudW1iZXIgfSBbcGFyYW0wLnRyYWlsaW5nTGluZUJyZWFrc11cbiAgICogVGhpcyB0YWJsZSBzaG91bGQgaGF2ZSBhdCBsZWFzdCB0aGlzIG51bWJlciBvZiBsaW5lIGJyZWFrcyB0byBzZXBhcmF0ZSBpdCBmcm9tIGFueSBmb2xsb3dpbmcgYmxvY2suXG4gICAqL1xuICBjbG9zZVRhYmxlICh7IHRhYmxlVG9TdHJpbmcsIGxlYWRpbmdMaW5lQnJlYWtzID0gMiwgdHJhaWxpbmdMaW5lQnJlYWtzID0gMiB9KSB7XG4gICAgY29uc3QgdGFibGUgPSB0aGlzLl9wb3BTdGFja0l0ZW0oKTtcbiAgICBjb25zdCBvdXRwdXQgPSB0YWJsZVRvU3RyaW5nKHRhYmxlLnJvd3MpO1xuICAgIGlmIChvdXRwdXQpIHtcbiAgICAgIGFkZFRleHQodGhpcy5fc3RhY2tJdGVtLCBvdXRwdXQsIGxlYWRpbmdMaW5lQnJlYWtzLCB0cmFpbGluZ0xpbmVCcmVha3MpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHJlbmRlcmVkIHRleHQgY29udGVudCBvZiB0aGlzIGJ1aWxkZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHsgc3RyaW5nIH1cbiAgICovXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gZ2V0VGV4dCh0aGlzLl9zdGFja0l0ZW0uZ2V0Um9vdCgpKTtcbiAgICAvLyBUaGVyZSBzaG91bGQgb25seSBiZSB0aGUgcm9vdCBpdGVtIGlmIGV2ZXJ5dGhpbmcgaXMgY2xvc2VkIHByb3Blcmx5LlxuICB9XG5cbn1cblxuZnVuY3Rpb24gZ2V0VGV4dCAoc3RhY2tJdGVtKSB7XG4gIGlmICghKFxuICAgIHN0YWNrSXRlbSBpbnN0YW5jZW9mIEJsb2NrU3RhY2tJdGVtXG4gICAgfHwgc3RhY2tJdGVtIGluc3RhbmNlb2YgTGlzdEl0ZW1TdGFja0l0ZW1cbiAgICB8fCBzdGFja0l0ZW0gaW5zdGFuY2VvZiBUYWJsZUNlbGxTdGFja0l0ZW1cbiAgKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignT25seSBibG9ja3MsIGxpc3QgaXRlbXMgYW5kIHRhYmxlIGNlbGxzIGNhbiBiZSByZXF1ZXN0ZWQgZm9yIHRleHQgY29udGVudHMuJyk7XG4gIH1cbiAgcmV0dXJuIChzdGFja0l0ZW0uaW5saW5lVGV4dEJ1aWxkZXIuaXNFbXB0eSgpKVxuICAgID8gc3RhY2tJdGVtLnJhd1RleHRcbiAgICA6IHN0YWNrSXRlbS5yYXdUZXh0ICsgc3RhY2tJdGVtLmlubGluZVRleHRCdWlsZGVyLnRvU3RyaW5nKCk7XG59XG5cbmZ1bmN0aW9uIGFkZFRleHQgKHN0YWNrSXRlbSwgdGV4dCwgbGVhZGluZ0xpbmVCcmVha3MsIHRyYWlsaW5nTGluZUJyZWFrcykge1xuICBpZiAoIShcbiAgICBzdGFja0l0ZW0gaW5zdGFuY2VvZiBCbG9ja1N0YWNrSXRlbVxuICAgIHx8IHN0YWNrSXRlbSBpbnN0YW5jZW9mIExpc3RJdGVtU3RhY2tJdGVtXG4gICAgfHwgc3RhY2tJdGVtIGluc3RhbmNlb2YgVGFibGVDZWxsU3RhY2tJdGVtXG4gICkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgYmxvY2tzLCBsaXN0IGl0ZW1zIGFuZCB0YWJsZSBjZWxscyBjYW4gY29udGFpbiB0ZXh0LicpO1xuICB9XG4gIGNvbnN0IHBhcmVudFRleHQgPSBnZXRUZXh0KHN0YWNrSXRlbSk7XG4gIGNvbnN0IGxpbmVCcmVha3MgPSBNYXRoLm1heChzdGFja0l0ZW0uc3Rhc2hlZExpbmVCcmVha3MsIGxlYWRpbmdMaW5lQnJlYWtzKTtcbiAgc3RhY2tJdGVtLmlubGluZVRleHRCdWlsZGVyLmNsZWFyKCk7XG4gIGlmIChwYXJlbnRUZXh0KSB7XG4gICAgc3RhY2tJdGVtLnJhd1RleHQgPSBwYXJlbnRUZXh0ICsgJ1xcbicucmVwZWF0KGxpbmVCcmVha3MpICsgdGV4dDtcbiAgfSBlbHNlIHtcbiAgICBzdGFja0l0ZW0ucmF3VGV4dCA9IHRleHQ7XG4gICAgc3RhY2tJdGVtLmxlYWRpbmdMaW5lQnJlYWtzID0gbGluZUJyZWFrcztcbiAgfVxuICBzdGFja0l0ZW0uc3Rhc2hlZExpbmVCcmVha3MgPSB0cmFpbGluZ0xpbmVCcmVha3M7XG59XG5cbi8qKlxuICogQHBhcmFtIHsgc3RyaW5nIH0gc3RyIEEgc3RyaW5nIHRvIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7IFRyYW5zZm9ybWVyU3RhY2tJdGVtIH0gdHJhbnNmb3JtZXIgQSB0cmFuc2Zvcm1lciBpdGVtICh3aXRoIHBvc3NpYmxlIGNvbnRpbnVhdGlvbikuXG4gKiBAcmV0dXJucyB7IHN0cmluZyB9XG4gKi9cbmZ1bmN0aW9uIGFwcGx5VHJhbnNmb3JtZXIgKHN0ciwgdHJhbnNmb3JtZXIpIHtcbiAgcmV0dXJuICgodHJhbnNmb3JtZXIpID8gYXBwbHlUcmFuc2Zvcm1lcih0cmFuc2Zvcm1lci50cmFuc2Zvcm0oc3RyKSwgdHJhbnNmb3JtZXIubmV4dCkgOiBzdHIpO1xufVxuXG4vKipcbiAqIENvbXBpbGUgc2VsZWN0b3JzIGludG8gYSBkZWNpc2lvbiB0cmVlLFxuICogcmV0dXJuIGEgZnVuY3Rpb24gaW50ZW5kZWQgZm9yIGJhdGNoIHByb2Nlc3NpbmcuXG4gKlxuICogQHBhcmFtICAgeyBPcHRpb25zIH0gW29wdGlvbnMgPSB7fV0gICBIdG1sVG9UZXh0IG9wdGlvbnMgKGRlZmF1bHRzLCBmb3JtYXR0ZXJzLCB1c2VyIG9wdGlvbnMgbWVyZ2VkLCBkZWR1cGxpY2F0ZWQpLlxuICogQHJldHVybnMgeyAoaHRtbDogc3RyaW5nLCBtZXRhZGF0YT86IGFueSkgPT4gc3RyaW5nIH0gUHJlLWNvbmZpZ3VyZWQgY29udmVydGVyIGZ1bmN0aW9uLlxuICogQHN0YXRpY1xuICovXG5mdW5jdGlvbiBjb21waWxlJDEgKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBzZWxlY3RvcnNXaXRob3V0Rm9ybWF0ID0gb3B0aW9ucy5zZWxlY3RvcnMuZmlsdGVyKHMgPT4gIXMuZm9ybWF0KTtcbiAgaWYgKHNlbGVjdG9yc1dpdGhvdXRGb3JtYXQubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0ZvbGxvd2luZyBzZWxlY3RvcnMgaGF2ZSBubyBzcGVjaWZpZWQgZm9ybWF0OiAnICtcbiAgICAgIHNlbGVjdG9yc1dpdGhvdXRGb3JtYXQubWFwKHMgPT4gYFxcYCR7cy5zZWxlY3Rvcn1cXGBgKS5qb2luKCcsICcpXG4gICAgKTtcbiAgfVxuICBjb25zdCBwaWNrZXIgPSBuZXcgc2VsZGVyZWUuRGVjaXNpb25UcmVlKFxuICAgIG9wdGlvbnMuc2VsZWN0b3JzLm1hcChzID0+IFtzLnNlbGVjdG9yLCBzXSlcbiAgKS5idWlsZChwbHVnaW5IdG1scGFyc2VyMi5ocDJCdWlsZGVyKTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMuZW5jb2RlQ2hhcmFjdGVycyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdGlvbnMuZW5jb2RlQ2hhcmFjdGVycyA9IG1ha2VSZXBsYWNlckZyb21EaWN0KG9wdGlvbnMuZW5jb2RlQ2hhcmFjdGVycyk7XG4gIH1cblxuICBjb25zdCBiYXNlU2VsZWN0b3JzUGlja2VyID0gbmV3IHNlbGRlcmVlLkRlY2lzaW9uVHJlZShcbiAgICBvcHRpb25zLmJhc2VFbGVtZW50cy5zZWxlY3RvcnMubWFwKChzLCBpKSA9PiBbcywgaSArIDFdKVxuICApLmJ1aWxkKHBsdWdpbkh0bWxwYXJzZXIyLmhwMkJ1aWxkZXIpO1xuICBmdW5jdGlvbiBmaW5kQmFzZUVsZW1lbnRzIChkb20pIHtcbiAgICByZXR1cm4gZmluZEJhc2VzKGRvbSwgb3B0aW9ucywgYmFzZVNlbGVjdG9yc1BpY2tlcik7XG4gIH1cblxuICBjb25zdCBsaW1pdGVkV2FsayA9IGxpbWl0ZWREZXB0aFJlY3Vyc2l2ZShcbiAgICBvcHRpb25zLmxpbWl0cy5tYXhEZXB0aCxcbiAgICByZWN1cnNpdmVXYWxrLFxuICAgIGZ1bmN0aW9uIChkb20sIGJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuYWRkSW5saW5lKG9wdGlvbnMubGltaXRzLmVsbGlwc2lzIHx8ICcnKTtcbiAgICB9XG4gICk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChodG1sLCBtZXRhZGF0YSA9IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBwcm9jZXNzKGh0bWwsIG1ldGFkYXRhLCBvcHRpb25zLCBwaWNrZXIsIGZpbmRCYXNlRWxlbWVudHMsIGxpbWl0ZWRXYWxrKTtcbiAgfTtcbn1cblxuXG4vKipcbiAqIENvbnZlcnQgZ2l2ZW4gSFRNTCBhY2NvcmRpbmcgdG8gcHJlcHJvY2Vzc2VkIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtIHsgc3RyaW5nIH0gaHRtbCBIVE1MIGNvbnRlbnQgdG8gY29udmVydC5cbiAqIEBwYXJhbSB7IGFueSB9IG1ldGFkYXRhIE9wdGlvbmFsIG1ldGFkYXRhIGZvciBIVE1MIGRvY3VtZW50LCBmb3IgdXNlIGluIGZvcm1hdHRlcnMuXG4gKiBAcGFyYW0geyBPcHRpb25zIH0gb3B0aW9ucyBIdG1sVG9UZXh0IG9wdGlvbnMgKHByZXByb2Nlc3NlZCkuXG4gKiBAcGFyYW0geyBpbXBvcnQoJ3NlbGRlcmVlJykuUGlja2VyPERvbU5vZGUsIFRhZ0RlZmluaXRpb24+IH0gcGlja2VyXG4gKiBUYWcgZGVmaW5pdGlvbiBwaWNrZXIgZm9yIERPTSBub2RlcyBwcm9jZXNzaW5nLlxuICogQHBhcmFtIHsgKGRvbTogRG9tTm9kZVtdKSA9PiBEb21Ob2RlW10gfSBmaW5kQmFzZUVsZW1lbnRzXG4gKiBGdW5jdGlvbiB0byBleHRyYWN0IGVsZW1lbnRzIGZyb20gSFRNTCBET01cbiAqIHRoYXQgd2lsbCBvbmx5IGJlIHByZXNlbnQgaW4gdGhlIG91dHB1dCB0ZXh0LlxuICogQHBhcmFtIHsgUmVjdXJzaXZlQ2FsbGJhY2sgfSB3YWxrIFJlY3Vyc2l2ZSBjYWxsYmFjay5cbiAqIEByZXR1cm5zIHsgc3RyaW5nIH1cbiAqL1xuZnVuY3Rpb24gcHJvY2VzcyAoaHRtbCwgbWV0YWRhdGEsIG9wdGlvbnMsIHBpY2tlciwgZmluZEJhc2VFbGVtZW50cywgd2Fsaykge1xuICBjb25zdCBtYXhJbnB1dExlbmd0aCA9IG9wdGlvbnMubGltaXRzLm1heElucHV0TGVuZ3RoO1xuICBpZiAobWF4SW5wdXRMZW5ndGggJiYgaHRtbCAmJiBodG1sLmxlbmd0aCA+IG1heElucHV0TGVuZ3RoKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYElucHV0IGxlbmd0aCAke2h0bWwubGVuZ3RofSBpcyBhYm92ZSBhbGxvd2VkIGxpbWl0IG9mICR7bWF4SW5wdXRMZW5ndGh9LiBUcnVuY2F0aW5nIHdpdGhvdXQgZWxsaXBzaXMuYFxuICAgICk7XG4gICAgaHRtbCA9IGh0bWwuc3Vic3RyaW5nKDAsIG1heElucHV0TGVuZ3RoKTtcbiAgfVxuXG4gIGNvbnN0IGRvY3VtZW50ID0gaHRtbHBhcnNlcjIucGFyc2VEb2N1bWVudChodG1sLCB7IGRlY29kZUVudGl0aWVzOiBvcHRpb25zLmRlY29kZUVudGl0aWVzIH0pO1xuICBjb25zdCBiYXNlcyA9IGZpbmRCYXNlRWxlbWVudHMoZG9jdW1lbnQuY2hpbGRyZW4pO1xuICBjb25zdCBidWlsZGVyID0gbmV3IEJsb2NrVGV4dEJ1aWxkZXIob3B0aW9ucywgcGlja2VyLCBtZXRhZGF0YSk7XG4gIHdhbGsoYmFzZXMsIGJ1aWxkZXIpO1xuICByZXR1cm4gYnVpbGRlci50b1N0cmluZygpO1xufVxuXG5cbmZ1bmN0aW9uIGZpbmRCYXNlcyAoZG9tLCBvcHRpb25zLCBiYXNlU2VsZWN0b3JzUGlja2VyKSB7XG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICBmdW5jdGlvbiByZWN1cnNpdmVXYWxrICh3YWxrLCAvKiogQHR5cGUgeyBEb21Ob2RlW10gfSAqLyBkb20pIHtcbiAgICBkb20gPSBkb20uc2xpY2UoMCwgb3B0aW9ucy5saW1pdHMubWF4Q2hpbGROb2Rlcyk7XG4gICAgZm9yIChjb25zdCBlbGVtIG9mIGRvbSkge1xuICAgICAgaWYgKGVsZW0udHlwZSAhPT0gJ3RhZycpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBwaWNrZWRTZWxlY3RvckluZGV4ID0gYmFzZVNlbGVjdG9yc1BpY2tlci5waWNrMShlbGVtKTtcbiAgICAgIGlmIChwaWNrZWRTZWxlY3RvckluZGV4ID4gMCkge1xuICAgICAgICByZXN1bHRzLnB1c2goeyBzZWxlY3RvckluZGV4OiBwaWNrZWRTZWxlY3RvckluZGV4LCBlbGVtZW50OiBlbGVtIH0pO1xuICAgICAgfSBlbHNlIGlmIChlbGVtLmNoaWxkcmVuKSB7XG4gICAgICAgIHdhbGsoZWxlbS5jaGlsZHJlbik7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0cy5sZW5ndGggPj0gb3B0aW9ucy5saW1pdHMubWF4QmFzZUVsZW1lbnRzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBsaW1pdGVkV2FsayA9IGxpbWl0ZWREZXB0aFJlY3Vyc2l2ZShcbiAgICBvcHRpb25zLmxpbWl0cy5tYXhEZXB0aCxcbiAgICByZWN1cnNpdmVXYWxrXG4gICk7XG4gIGxpbWl0ZWRXYWxrKGRvbSk7XG5cbiAgaWYgKG9wdGlvbnMuYmFzZUVsZW1lbnRzLm9yZGVyQnkgIT09ICdvY2N1cnJlbmNlJykgeyAvLyAnc2VsZWN0b3JzJ1xuICAgIHJlc3VsdHMuc29ydCgoYSwgYikgPT4gYS5zZWxlY3RvckluZGV4IC0gYi5zZWxlY3RvckluZGV4KTtcbiAgfVxuICByZXR1cm4gKG9wdGlvbnMuYmFzZUVsZW1lbnRzLnJldHVybkRvbUJ5RGVmYXVsdCAmJiByZXN1bHRzLmxlbmd0aCA9PT0gMClcbiAgICA/IGRvbVxuICAgIDogcmVzdWx0cy5tYXAoeCA9PiB4LmVsZW1lbnQpO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHRvIHdhbGsgdGhyb3VnaCBET00gbm9kZXMgYW5kIGFjY3VtdWxhdGUgdGhlaXIgc3RyaW5nIHJlcHJlc2VudGF0aW9ucy5cbiAqXG4gKiBAcGFyYW0gICB7IFJlY3Vyc2l2ZUNhbGxiYWNrIH0gd2FsayAgICBSZWN1cnNpdmUgY2FsbGJhY2suXG4gKiBAcGFyYW0gICB7IERvbU5vZGVbXSB9ICAgICAgICAgW2RvbV0gICBOb2RlcyBhcnJheSB0byBwcm9jZXNzLlxuICogQHBhcmFtICAgeyBCbG9ja1RleHRCdWlsZGVyIH0gIGJ1aWxkZXIgUGFzc2VkIGFyb3VuZCB0byBhY2N1bXVsYXRlIG91dHB1dCB0ZXh0LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjdXJzaXZlV2FsayAod2FsaywgZG9tLCBidWlsZGVyKSB7XG4gIGlmICghZG9tKSB7IHJldHVybjsgfVxuXG4gIGNvbnN0IG9wdGlvbnMgPSBidWlsZGVyLm9wdGlvbnM7XG5cbiAgY29uc3QgdG9vTWFueUNoaWxkTm9kZXMgPSBkb20ubGVuZ3RoID4gb3B0aW9ucy5saW1pdHMubWF4Q2hpbGROb2RlcztcbiAgaWYgKHRvb01hbnlDaGlsZE5vZGVzKSB7XG4gICAgZG9tID0gZG9tLnNsaWNlKDAsIG9wdGlvbnMubGltaXRzLm1heENoaWxkTm9kZXMpO1xuICAgIGRvbS5wdXNoKHtcbiAgICAgIGRhdGE6IG9wdGlvbnMubGltaXRzLmVsbGlwc2lzLFxuICAgICAgdHlwZTogJ3RleHQnXG4gICAgfSk7XG4gIH1cblxuICBmb3IgKGNvbnN0IGVsZW0gb2YgZG9tKSB7XG4gICAgc3dpdGNoIChlbGVtLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3RleHQnOiB7XG4gICAgICAgIGJ1aWxkZXIuYWRkSW5saW5lKGVsZW0uZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAndGFnJzoge1xuICAgICAgICBjb25zdCB0YWdEZWZpbml0aW9uID0gYnVpbGRlci5waWNrZXIucGljazEoZWxlbSk7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0dGVyc1t0YWdEZWZpbml0aW9uLmZvcm1hdF07XG4gICAgICAgIGZvcm1hdChlbGVtLCB3YWxrLCBidWlsZGVyLCB0YWdEZWZpbml0aW9uLm9wdGlvbnMgfHwge30pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm47XG59XG5cbi8qKlxuICogQHBhcmFtIHsgT2JqZWN0PHN0cmluZyxzdHJpbmcgfCBmYWxzZT4gfSBkaWN0XG4gKiBBIGRpY3Rpb25hcnkgd2hlcmUga2V5cyBhcmUgY2hhcmFjdGVycyB0byByZXBsYWNlXG4gKiBhbmQgdmFsdWVzIGFyZSByZXBsYWNlbWVudCBzdHJpbmdzLlxuICpcbiAqIEZpcnN0IGNvZGUgcG9pbnQgZnJvbSBkaWN0IGtleXMgaXMgdXNlZC5cbiAqIENvbXBvdW5kIGVtb2ppcyB3aXRoIFpXSiBhcmUgbm90IHN1cHBvcnRlZCAobm90IHVudGlsIE5vZGUgMTYpLlxuICpcbiAqIEByZXR1cm5zIHsgKChzdHI6IHN0cmluZykgPT4gc3RyaW5nKSB8IHVuZGVmaW5lZCB9XG4gKi9cbmZ1bmN0aW9uIG1ha2VSZXBsYWNlckZyb21EaWN0IChkaWN0KSB7XG4gIGlmICghZGljdCB8fCBPYmplY3Qua2V5cyhkaWN0KS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIC8qKiBAdHlwZSB7IFtzdHJpbmcsIHN0cmluZ11bXSB9ICovXG4gIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhkaWN0KS5maWx0ZXIoKFssIHZdKSA9PiB2ICE9PSBmYWxzZSk7XG4gIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgICBlbnRyaWVzXG4gICAgICAubWFwKChbY10pID0+IGAoJHt1bmljb2RlRXNjYXBlKFsuLi5jXVswXSl9KWApXG4gICAgICAuam9pbignfCcpLFxuICAgICdnJ1xuICApO1xuICBjb25zdCB2YWx1ZXMgPSBlbnRyaWVzLm1hcCgoWywgdl0pID0+IHYpO1xuICBjb25zdCByZXBsYWNlciA9IChtLCAuLi5jZ3MpID0+IHZhbHVlc1tjZ3MuZmluZEluZGV4KGNnID0+IGNnKV07XG4gIHJldHVybiAoc3RyKSA9PiBzdHIucmVwbGFjZShyZWdleCwgcmVwbGFjZXIpO1xufVxuXG4vKipcbiAqIER1bW15IGZvcm1hdHRlciB0aGF0IGRpc2NhcmRzIHRoZSBpbnB1dCBhbmQgZG9lcyBub3RoaW5nLlxuICpcbiAqIEB0eXBlIHsgRm9ybWF0Q2FsbGJhY2sgfVxuICovXG5mdW5jdGlvbiBmb3JtYXRTa2lwIChlbGVtLCB3YWxrLCBidWlsZGVyLCBmb3JtYXRPcHRpb25zKSB7XG4gIC8qIGRvIG5vdGhpbmcgKi9cbn1cblxuLyoqXG4gKiBJbnNlcnQgdGhlIGdpdmVuIHN0cmluZyBsaXRlcmFsIGlubGluZSBpbnN0ZWFkIG9mIGEgdGFnLlxuICpcbiAqIEB0eXBlIHsgRm9ybWF0Q2FsbGJhY2sgfVxuICovXG5mdW5jdGlvbiBmb3JtYXRJbmxpbmVTdHJpbmcgKGVsZW0sIHdhbGssIGJ1aWxkZXIsIGZvcm1hdE9wdGlvbnMpIHtcbiAgYnVpbGRlci5hZGRMaXRlcmFsKGZvcm1hdE9wdGlvbnMuc3RyaW5nIHx8ICcnKTtcbn1cblxuLyoqXG4gKiBJbnNlcnQgYSBibG9jayB3aXRoIHRoZSBnaXZlbiBzdHJpbmcgbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgdGFnLlxuICpcbiAqIEB0eXBlIHsgRm9ybWF0Q2FsbGJhY2sgfVxuICovXG5mdW5jdGlvbiBmb3JtYXRCbG9ja1N0cmluZyAoZWxlbSwgd2FsaywgYnVpbGRlciwgZm9ybWF0T3B0aW9ucykge1xuICBidWlsZGVyLm9wZW5CbG9jayh7IGxlYWRpbmdMaW5lQnJlYWtzOiBmb3JtYXRPcHRpb25zLmxlYWRpbmdMaW5lQnJlYWtzIHx8IDIgfSk7XG4gIGJ1aWxkZXIuYWRkTGl0ZXJhbChmb3JtYXRPcHRpb25zLnN0cmluZyB8fCAnJyk7XG4gIGJ1aWxkZXIuY2xvc2VCbG9jayh7IHRyYWlsaW5nTGluZUJyZWFrczogZm9ybWF0T3B0aW9ucy50cmFpbGluZ0xpbmVCcmVha3MgfHwgMiB9KTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIGFuIGlubGluZS1sZXZlbCBlbGVtZW50LlxuICpcbiAqIEB0eXBlIHsgRm9ybWF0Q2FsbGJhY2sgfVxuICovXG5mdW5jdGlvbiBmb3JtYXRJbmxpbmUgKGVsZW0sIHdhbGssIGJ1aWxkZXIsIGZvcm1hdE9wdGlvbnMpIHtcbiAgd2FsayhlbGVtLmNoaWxkcmVuLCBidWlsZGVyKTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIGEgYmxvY2stbGV2ZWwgY29udGFpbmVyLlxuICpcbiAqIEB0eXBlIHsgRm9ybWF0Q2FsbGJhY2sgfVxuICovXG5mdW5jdGlvbiBmb3JtYXRCbG9jayQxIChlbGVtLCB3YWxrLCBidWlsZGVyLCBmb3JtYXRPcHRpb25zKSB7XG4gIGJ1aWxkZXIub3BlbkJsb2NrKHsgbGVhZGluZ0xpbmVCcmVha3M6IGZvcm1hdE9wdGlvbnMubGVhZGluZ0xpbmVCcmVha3MgfHwgMiB9KTtcbiAgd2FsayhlbGVtLmNoaWxkcmVuLCBidWlsZGVyKTtcbiAgYnVpbGRlci5jbG9zZUJsb2NrKHsgdHJhaWxpbmdMaW5lQnJlYWtzOiBmb3JtYXRPcHRpb25zLnRyYWlsaW5nTGluZUJyZWFrcyB8fCAyIH0pO1xufVxuXG5mdW5jdGlvbiByZW5kZXJPcGVuVGFnIChlbGVtKSB7XG4gIGNvbnN0IGF0dHJzID0gKGVsZW0uYXR0cmlicyAmJiBlbGVtLmF0dHJpYnMubGVuZ3RoKVxuICAgID8gJyAnICsgT2JqZWN0LmVudHJpZXMoZWxlbS5hdHRyaWJzKVxuICAgICAgLm1hcCgoW2ssIHZdKSA9PiAoKHYgPT09ICcnKSA/IGsgOiBgJHtrfT0ke3YucmVwbGFjZSgvXCIvZywgJyZxdW90OycpfWApKVxuICAgICAgLmpvaW4oJyAnKVxuICAgIDogJyc7XG4gIHJldHVybiBgPCR7ZWxlbS5uYW1lfSR7YXR0cnN9PmA7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNsb3NlVGFnIChlbGVtKSB7XG4gIHJldHVybiBgPC8ke2VsZW0ubmFtZX0+YDtcbn1cblxuLyoqXG4gKiBSZW5kZXIgYW4gZWxlbWVudCBhcyBpbmxpbmUgSFRNTCB0YWcsIHdhbGsgdGhyb3VnaCBpdCdzIGNoaWxkcmVuLlxuICpcbiAqIEB0eXBlIHsgRm9ybWF0Q2FsbGJhY2sgfVxuICovXG5mdW5jdGlvbiBmb3JtYXRJbmxpbmVUYWcgKGVsZW0sIHdhbGssIGJ1aWxkZXIsIGZvcm1hdE9wdGlvbnMpIHtcbiAgYnVpbGRlci5zdGFydE5vV3JhcCgpO1xuICBidWlsZGVyLmFkZExpdGVyYWwocmVuZGVyT3BlblRhZyhlbGVtKSk7XG4gIGJ1aWxkZXIuc3RvcE5vV3JhcCgpO1xuICB3YWxrKGVsZW0uY2hpbGRyZW4sIGJ1aWxkZXIpO1xuICBidWlsZGVyLnN0YXJ0Tm9XcmFwKCk7XG4gIGJ1aWxkZXIuYWRkTGl0ZXJhbChyZW5kZXJDbG9zZVRhZyhlbGVtKSk7XG4gIGJ1aWxkZXIuc3RvcE5vV3JhcCgpO1xufVxuXG4vKipcbiAqIFJlbmRlciBhbiBlbGVtZW50IGFzIEhUTUwgYmxvY2sgYmFnLCB3YWxrIHRocm91Z2ggaXQncyBjaGlsZHJlbi5cbiAqXG4gKiBAdHlwZSB7IEZvcm1hdENhbGxiYWNrIH1cbiAqL1xuZnVuY3Rpb24gZm9ybWF0QmxvY2tUYWcgKGVsZW0sIHdhbGssIGJ1aWxkZXIsIGZvcm1hdE9wdGlvbnMpIHtcbiAgYnVpbGRlci5vcGVuQmxvY2soeyBsZWFkaW5nTGluZUJyZWFrczogZm9ybWF0T3B0aW9ucy5sZWFkaW5nTGluZUJyZWFrcyB8fCAyIH0pO1xuICBidWlsZGVyLnN0YXJ0Tm9XcmFwKCk7XG4gIGJ1aWxkZXIuYWRkTGl0ZXJhbChyZW5kZXJPcGVuVGFnKGVsZW0pKTtcbiAgYnVpbGRlci5zdG9wTm9XcmFwKCk7XG4gIHdhbGsoZWxlbS5jaGlsZHJlbiwgYnVpbGRlcik7XG4gIGJ1aWxkZXIuc3RhcnROb1dyYXAoKTtcbiAgYnVpbGRlci5hZGRMaXRlcmFsKHJlbmRlckNsb3NlVGFnKGVsZW0pKTtcbiAgYnVpbGRlci5zdG9wTm9XcmFwKCk7XG4gIGJ1aWxkZXIuY2xvc2VCbG9jayh7IHRyYWlsaW5nTGluZUJyZWFrczogZm9ybWF0T3B0aW9ucy50cmFpbGluZ0xpbmVCcmVha3MgfHwgMiB9KTtcbn1cblxuLyoqXG4gKiBSZW5kZXIgYW4gZWxlbWVudCB3aXRoIGFsbCBpdCdzIGNoaWxkcmVuIGFzIGlubGluZSBIVE1MLlxuICpcbiAqIEB0eXBlIHsgRm9ybWF0Q2FsbGJhY2sgfVxuICovXG5mdW5jdGlvbiBmb3JtYXRJbmxpbmVIdG1sIChlbGVtLCB3YWxrLCBidWlsZGVyLCBmb3JtYXRPcHRpb25zKSB7XG4gIGJ1aWxkZXIuc3RhcnROb1dyYXAoKTtcbiAgYnVpbGRlci5hZGRMaXRlcmFsKFxuICAgIGRvbVNlcmlhbGl6ZXIucmVuZGVyKGVsZW0sIHsgZGVjb2RlRW50aXRpZXM6IGJ1aWxkZXIub3B0aW9ucy5kZWNvZGVFbnRpdGllcyB9KVxuICApO1xuICBidWlsZGVyLnN0b3BOb1dyYXAoKTtcbn1cblxuLyoqXG4gKiBSZW5kZXIgYW4gZWxlbWVudCB3aXRoIGFsbCBpdCdzIGNoaWxkcmVuIGFzIEhUTUwgYmxvY2suXG4gKlxuICogQHR5cGUgeyBGb3JtYXRDYWxsYmFjayB9XG4gKi9cbmZ1bmN0aW9uIGZvcm1hdEJsb2NrSHRtbCAoZWxlbSwgd2FsaywgYnVpbGRlciwgZm9ybWF0T3B0aW9ucykge1xuICBidWlsZGVyLm9wZW5CbG9jayh7IGxlYWRpbmdMaW5lQnJlYWtzOiBmb3JtYXRPcHRpb25zLmxlYWRpbmdMaW5lQnJlYWtzIHx8IDIgfSk7XG4gIGJ1aWxkZXIuc3RhcnROb1dyYXAoKTtcbiAgYnVpbGRlci5hZGRMaXRlcmFsKFxuICAgIGRvbVNlcmlhbGl6ZXIucmVuZGVyKGVsZW0sIHsgZGVjb2RlRW50aXRpZXM6IGJ1aWxkZXIub3B0aW9ucy5kZWNvZGVFbnRpdGllcyB9KVxuICApO1xuICBidWlsZGVyLnN0b3BOb1dyYXAoKTtcbiAgYnVpbGRlci5jbG9zZUJsb2NrKHsgdHJhaWxpbmdMaW5lQnJlYWtzOiBmb3JtYXRPcHRpb25zLnRyYWlsaW5nTGluZUJyZWFrcyB8fCAyIH0pO1xufVxuXG4vKipcbiAqIFJlbmRlciBpbmxpbmUgZWxlbWVudCB3cmFwcGVkIHdpdGggZ2l2ZW4gc3RyaW5ncy5cbiAqXG4gKiBAdHlwZSB7IEZvcm1hdENhbGxiYWNrIH1cbiAqL1xuZnVuY3Rpb24gZm9ybWF0SW5saW5lU3Vycm91bmQgKGVsZW0sIHdhbGssIGJ1aWxkZXIsIGZvcm1hdE9wdGlvbnMpIHtcbiAgYnVpbGRlci5hZGRMaXRlcmFsKGZvcm1hdE9wdGlvbnMucHJlZml4IHx8ICcnKTtcbiAgd2FsayhlbGVtLmNoaWxkcmVuLCBidWlsZGVyKTtcbiAgYnVpbGRlci5hZGRMaXRlcmFsKGZvcm1hdE9wdGlvbnMuc3VmZml4IHx8ICcnKTtcbn1cblxudmFyIGdlbmVyaWNGb3JtYXR0ZXJzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGJsb2NrOiBmb3JtYXRCbG9jayQxLFxuICBibG9ja0h0bWw6IGZvcm1hdEJsb2NrSHRtbCxcbiAgYmxvY2tTdHJpbmc6IGZvcm1hdEJsb2NrU3RyaW5nLFxuICBibG9ja1RhZzogZm9ybWF0QmxvY2tUYWcsXG4gIGlubGluZTogZm9ybWF0SW5saW5lLFxuICBpbmxpbmVIdG1sOiBmb3JtYXRJbmxpbmVIdG1sLFxuICBpbmxpbmVTdHJpbmc6IGZvcm1hdElubGluZVN0cmluZyxcbiAgaW5saW5lU3Vycm91bmQ6IGZvcm1hdElubGluZVN1cnJvdW5kLFxuICBpbmxpbmVUYWc6IGZvcm1hdElubGluZVRhZyxcbiAgc2tpcDogZm9ybWF0U2tpcFxufSk7XG5cbmZ1bmN0aW9uIGdldFJvdyAobWF0cml4LCBqKSB7XG4gIGlmICghbWF0cml4W2pdKSB7IG1hdHJpeFtqXSA9IFtdOyB9XG4gIHJldHVybiBtYXRyaXhbal07XG59XG5cbmZ1bmN0aW9uIGZpbmRGaXJzdFZhY2FudEluZGV4IChyb3csIHggPSAwKSB7XG4gIHdoaWxlIChyb3dbeF0pIHsgeCsrOyB9XG4gIHJldHVybiB4O1xufVxuXG5mdW5jdGlvbiB0cmFuc3Bvc2VJblBsYWNlIChtYXRyaXgsIG1heFNpemUpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhTaXplOyBpKyspIHtcbiAgICBjb25zdCByb3dJID0gZ2V0Um93KG1hdHJpeCwgaSk7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBpOyBqKyspIHtcbiAgICAgIGNvbnN0IHJvd0ogPSBnZXRSb3cobWF0cml4LCBqKTtcbiAgICAgIGlmIChyb3dJW2pdIHx8IHJvd0pbaV0pIHtcbiAgICAgICAgY29uc3QgdGVtcCA9IHJvd0lbal07XG4gICAgICAgIHJvd0lbal0gPSByb3dKW2ldO1xuICAgICAgICByb3dKW2ldID0gdGVtcDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHV0Q2VsbEludG9MYXlvdXQgKGNlbGwsIGxheW91dCwgYmFzZVJvdywgYmFzZUNvbCkge1xuICBmb3IgKGxldCByID0gMDsgciA8IGNlbGwucm93c3BhbjsgcisrKSB7XG4gICAgY29uc3QgbGF5b3V0Um93ID0gZ2V0Um93KGxheW91dCwgYmFzZVJvdyArIHIpO1xuICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY2VsbC5jb2xzcGFuOyBjKyspIHtcbiAgICAgIGxheW91dFJvd1tiYXNlQ29sICsgY10gPSBjZWxsO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRPckluaXRPZmZzZXQgKG9mZnNldHMsIGluZGV4KSB7XG4gIGlmIChvZmZzZXRzW2luZGV4XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb2Zmc2V0c1tpbmRleF0gPSAoaW5kZXggPT09IDApID8gMCA6IDEgKyBnZXRPckluaXRPZmZzZXQob2Zmc2V0cywgaW5kZXggLSAxKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0c1tpbmRleF07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU9mZnNldCAob2Zmc2V0cywgYmFzZSwgc3BhbiwgdmFsdWUpIHtcbiAgb2Zmc2V0c1tiYXNlICsgc3Bhbl0gPSBNYXRoLm1heChcbiAgICBnZXRPckluaXRPZmZzZXQob2Zmc2V0cywgYmFzZSArIHNwYW4pLFxuICAgIGdldE9ySW5pdE9mZnNldChvZmZzZXRzLCBiYXNlKSArIHZhbHVlXG4gICk7XG59XG5cbi8qKlxuICogUmVuZGVyIGEgdGFibGUgaW50byBhIHN0cmluZy5cbiAqIENlbGxzIGNhbiBjb250YWluIG11bHRpbGluZSB0ZXh0IGFuZCBzcGFuIGFjcm9zcyBtdWx0aXBsZSByb3dzIGFuZCBjb2x1bW5zLlxuICpcbiAqIE1vZGlmaWVzIGNlbGxzIHRvIGFkZCBsaW5lcyBhcnJheS5cbiAqXG4gKiBAcGFyYW0geyBUYWJsZVByaW50ZXJDZWxsW11bXSB9IHRhYmxlUm93cyBUYWJsZSB0byByZW5kZXIuXG4gKiBAcGFyYW0geyBudW1iZXIgfSByb3dTcGFjaW5nIE51bWJlciBvZiBzcGFjZXMgYmV0d2VlbiBjb2x1bW5zLlxuICogQHBhcmFtIHsgbnVtYmVyIH0gY29sU3BhY2luZyBOdW1iZXIgb2YgZW1wdHkgbGluZXMgYmV0d2VlbiByb3dzLlxuICogQHJldHVybnMgeyBzdHJpbmcgfVxuICovXG5mdW5jdGlvbiB0YWJsZVRvU3RyaW5nICh0YWJsZVJvd3MsIHJvd1NwYWNpbmcsIGNvbFNwYWNpbmcpIHtcbiAgY29uc3QgbGF5b3V0ID0gW107XG4gIGxldCBjb2xOdW1iZXIgPSAwO1xuICBjb25zdCByb3dOdW1iZXIgPSB0YWJsZVJvd3MubGVuZ3RoO1xuICBjb25zdCByb3dPZmZzZXRzID0gWzBdO1xuICAvLyBGaWxsIHRoZSBsYXlvdXQgdGFibGUgYW5kIHJvdyBvZmZzZXRzIHJvdy1ieS1yb3cuXG4gIGZvciAobGV0IGogPSAwOyBqIDwgcm93TnVtYmVyOyBqKyspIHtcbiAgICBjb25zdCBsYXlvdXRSb3cgPSBnZXRSb3cobGF5b3V0LCBqKTtcbiAgICBjb25zdCBjZWxscyA9IHRhYmxlUm93c1tqXTtcbiAgICBsZXQgeCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2VsbCA9IGNlbGxzW2ldO1xuICAgICAgeCA9IGZpbmRGaXJzdFZhY2FudEluZGV4KGxheW91dFJvdywgeCk7XG4gICAgICBwdXRDZWxsSW50b0xheW91dChjZWxsLCBsYXlvdXQsIGosIHgpO1xuICAgICAgeCArPSBjZWxsLmNvbHNwYW47XG4gICAgICBjZWxsLmxpbmVzID0gY2VsbC50ZXh0LnNwbGl0KCdcXG4nKTtcbiAgICAgIGNvbnN0IGNlbGxIZWlnaHQgPSBjZWxsLmxpbmVzLmxlbmd0aDtcbiAgICAgIHVwZGF0ZU9mZnNldChyb3dPZmZzZXRzLCBqLCBjZWxsLnJvd3NwYW4sIGNlbGxIZWlnaHQgKyByb3dTcGFjaW5nKTtcbiAgICB9XG4gICAgY29sTnVtYmVyID0gKGxheW91dFJvdy5sZW5ndGggPiBjb2xOdW1iZXIpID8gbGF5b3V0Um93Lmxlbmd0aCA6IGNvbE51bWJlcjtcbiAgfVxuXG4gIHRyYW5zcG9zZUluUGxhY2UobGF5b3V0LCAocm93TnVtYmVyID4gY29sTnVtYmVyKSA/IHJvd051bWJlciA6IGNvbE51bWJlcik7XG5cbiAgY29uc3Qgb3V0cHV0TGluZXMgPSBbXTtcbiAgY29uc3QgY29sT2Zmc2V0cyA9IFswXTtcbiAgLy8gRmlsbCBjb2x1bW4gb2Zmc2V0cyBhbmQgb3V0cHV0IGxpbmVzIGNvbHVtbi1ieS1jb2x1bW4uXG4gIGZvciAobGV0IHggPSAwOyB4IDwgY29sTnVtYmVyOyB4KyspIHtcbiAgICBsZXQgeSA9IDA7XG4gICAgbGV0IGNlbGw7XG4gICAgY29uc3Qgcm93c0luVGhpc0NvbHVtbiA9IE1hdGgubWluKHJvd051bWJlciwgbGF5b3V0W3hdLmxlbmd0aCk7XG4gICAgd2hpbGUgKHkgPCByb3dzSW5UaGlzQ29sdW1uKSB7XG4gICAgICBjZWxsID0gbGF5b3V0W3hdW3ldO1xuICAgICAgaWYgKGNlbGwpIHtcbiAgICAgICAgaWYgKCFjZWxsLnJlbmRlcmVkKSB7XG4gICAgICAgICAgbGV0IGNlbGxXaWR0aCA9IDA7XG4gICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjZWxsLmxpbmVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lID0gY2VsbC5saW5lc1tqXTtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVPZmZzZXQgPSByb3dPZmZzZXRzW3ldICsgajtcbiAgICAgICAgICAgIG91dHB1dExpbmVzW2xpbmVPZmZzZXRdID0gKG91dHB1dExpbmVzW2xpbmVPZmZzZXRdIHx8ICcnKS5wYWRFbmQoY29sT2Zmc2V0c1t4XSkgKyBsaW5lO1xuICAgICAgICAgICAgY2VsbFdpZHRoID0gKGxpbmUubGVuZ3RoID4gY2VsbFdpZHRoKSA/IGxpbmUubGVuZ3RoIDogY2VsbFdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVPZmZzZXQoY29sT2Zmc2V0cywgeCwgY2VsbC5jb2xzcGFuLCBjZWxsV2lkdGggKyBjb2xTcGFjaW5nKTtcbiAgICAgICAgICBjZWxsLnJlbmRlcmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB5ICs9IGNlbGwucm93c3BhbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGxpbmVPZmZzZXQgPSByb3dPZmZzZXRzW3ldO1xuICAgICAgICBvdXRwdXRMaW5lc1tsaW5lT2Zmc2V0XSA9IChvdXRwdXRMaW5lc1tsaW5lT2Zmc2V0XSB8fCAnJyk7XG4gICAgICAgIHkrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0TGluZXMuam9pbignXFxuJyk7XG59XG5cbi8qKlxuICogUHJvY2VzcyBhIGxpbmUtYnJlYWsuXG4gKlxuICogQHR5cGUgeyBGb3JtYXRDYWxsYmFjayB9XG4gKi9cbmZ1bmN0aW9uIGZvcm1hdExpbmVCcmVhayAoZWxlbSwgd2FsaywgYnVpbGRlciwgZm9ybWF0T3B0aW9ucykge1xuICBidWlsZGVyLmFkZExpbmVCcmVhaygpO1xufVxuXG4vKipcbiAqIFByb2Nlc3MgYSBgd2JyYCB0YWcgKHdvcmQgYnJlYWsgb3Bwb3J0dW5pdHkpLlxuICpcbiAqIEB0eXBlIHsgRm9ybWF0Q2FsbGJhY2sgfVxuICovXG5mdW5jdGlvbiBmb3JtYXRXYnIgKGVsZW0sIHdhbGssIGJ1aWxkZXIsIGZvcm1hdE9wdGlvbnMpIHtcbiAgYnVpbGRlci5hZGRXb3JkQnJlYWtPcHBvcnR1bml0eSgpO1xufVxuXG4vKipcbiAqIFByb2Nlc3MgYSBob3Jpem9udGFsIGxpbmUuXG4gKlxuICogQHR5cGUgeyBGb3JtYXRDYWxsYmFjayB9XG4gKi9cbmZ1bmN0aW9uIGZvcm1hdEhvcml6b250YWxMaW5lIChlbGVtLCB3YWxrLCBidWlsZGVyLCBmb3JtYXRPcHRpb25zKSB7XG4gIGJ1aWxkZXIub3BlbkJsb2NrKHsgbGVhZGluZ0xpbmVCcmVha3M6IGZvcm1hdE9wdGlvbnMubGVhZGluZ0xpbmVCcmVha3MgfHwgMiB9KTtcbiAgYnVpbGRlci5hZGRJbmxpbmUoJy0nLnJlcGVhdChmb3JtYXRPcHRpb25zLmxlbmd0aCB8fCBidWlsZGVyLm9wdGlvbnMud29yZHdyYXAgfHwgNDApKTtcbiAgYnVpbGRlci5jbG9zZUJsb2NrKHsgdHJhaWxpbmdMaW5lQnJlYWtzOiBmb3JtYXRPcHRpb25zLnRyYWlsaW5nTGluZUJyZWFrcyB8fCAyIH0pO1xufVxuXG4vKipcbiAqIFByb2Nlc3MgYSBwYXJhZ3JhcGguXG4gKlxuICogQHR5cGUgeyBGb3JtYXRDYWxsYmFjayB9XG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFBhcmFncmFwaCAoZWxlbSwgd2FsaywgYnVpbGRlciwgZm9ybWF0T3B0aW9ucykge1xuICBidWlsZGVyLm9wZW5CbG9jayh7IGxlYWRpbmdMaW5lQnJlYWtzOiBmb3JtYXRPcHRpb25zLmxlYWRpbmdMaW5lQnJlYWtzIHx8IDIgfSk7XG4gIHdhbGsoZWxlbS5jaGlsZHJlbiwgYnVpbGRlcik7XG4gIGJ1aWxkZXIuY2xvc2VCbG9jayh7IHRyYWlsaW5nTGluZUJyZWFrczogZm9ybWF0T3B0aW9ucy50cmFpbGluZ0xpbmVCcmVha3MgfHwgMiB9KTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIGEgcHJlZm9ybWF0dGVkIGNvbnRlbnQuXG4gKlxuICogQHR5cGUgeyBGb3JtYXRDYWxsYmFjayB9XG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFByZSAoZWxlbSwgd2FsaywgYnVpbGRlciwgZm9ybWF0T3B0aW9ucykge1xuICBidWlsZGVyLm9wZW5CbG9jayh7XG4gICAgaXNQcmU6IHRydWUsXG4gICAgbGVhZGluZ0xpbmVCcmVha3M6IGZvcm1hdE9wdGlvbnMubGVhZGluZ0xpbmVCcmVha3MgfHwgMlxuICB9KTtcbiAgd2FsayhlbGVtLmNoaWxkcmVuLCBidWlsZGVyKTtcbiAgYnVpbGRlci5jbG9zZUJsb2NrKHsgdHJhaWxpbmdMaW5lQnJlYWtzOiBmb3JtYXRPcHRpb25zLnRyYWlsaW5nTGluZUJyZWFrcyB8fCAyIH0pO1xufVxuXG4vKipcbiAqIFByb2Nlc3MgYSBoZWFkaW5nLlxuICpcbiAqIEB0eXBlIHsgRm9ybWF0Q2FsbGJhY2sgfVxuICovXG5mdW5jdGlvbiBmb3JtYXRIZWFkaW5nIChlbGVtLCB3YWxrLCBidWlsZGVyLCBmb3JtYXRPcHRpb25zKSB7XG4gIGJ1aWxkZXIub3BlbkJsb2NrKHsgbGVhZGluZ0xpbmVCcmVha3M6IGZvcm1hdE9wdGlvbnMubGVhZGluZ0xpbmVCcmVha3MgfHwgMiB9KTtcbiAgaWYgKGZvcm1hdE9wdGlvbnMudXBwZXJjYXNlICE9PSBmYWxzZSkge1xuICAgIGJ1aWxkZXIucHVzaFdvcmRUcmFuc2Zvcm0oc3RyID0+IHN0ci50b1VwcGVyQ2FzZSgpKTtcbiAgICB3YWxrKGVsZW0uY2hpbGRyZW4sIGJ1aWxkZXIpO1xuICAgIGJ1aWxkZXIucG9wV29yZFRyYW5zZm9ybSgpO1xuICB9IGVsc2Uge1xuICAgIHdhbGsoZWxlbS5jaGlsZHJlbiwgYnVpbGRlcik7XG4gIH1cbiAgYnVpbGRlci5jbG9zZUJsb2NrKHsgdHJhaWxpbmdMaW5lQnJlYWtzOiBmb3JtYXRPcHRpb25zLnRyYWlsaW5nTGluZUJyZWFrcyB8fCAyIH0pO1xufVxuXG4vKipcbiAqIFByb2Nlc3MgYSBibG9ja3F1b3RlLlxuICpcbiAqIEB0eXBlIHsgRm9ybWF0Q2FsbGJhY2sgfVxuICovXG5mdW5jdGlvbiBmb3JtYXRCbG9ja3F1b3RlIChlbGVtLCB3YWxrLCBidWlsZGVyLCBmb3JtYXRPcHRpb25zKSB7XG4gIGJ1aWxkZXIub3BlbkJsb2NrKHtcbiAgICBsZWFkaW5nTGluZUJyZWFrczogZm9ybWF0T3B0aW9ucy5sZWFkaW5nTGluZUJyZWFrcyB8fCAyLFxuICAgIHJlc2VydmVkTGluZUxlbmd0aDogMlxuICB9KTtcbiAgd2FsayhlbGVtLmNoaWxkcmVuLCBidWlsZGVyKTtcbiAgYnVpbGRlci5jbG9zZUJsb2NrKHtcbiAgICB0cmFpbGluZ0xpbmVCcmVha3M6IGZvcm1hdE9wdGlvbnMudHJhaWxpbmdMaW5lQnJlYWtzIHx8IDIsXG4gICAgYmxvY2tUcmFuc2Zvcm06IHN0ciA9PiAoKGZvcm1hdE9wdGlvbnMudHJpbUVtcHR5TGluZXMgIT09IGZhbHNlKSA/IHRyaW1DaGFyYWN0ZXIoc3RyLCAnXFxuJykgOiBzdHIpXG4gICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAubWFwKGxpbmUgPT4gJz4gJyArIGxpbmUpXG4gICAgICAuam9pbignXFxuJylcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHdpdGhCcmFja2V0cyAoc3RyLCBicmFja2V0cykge1xuICBpZiAoIWJyYWNrZXRzKSB7IHJldHVybiBzdHI7IH1cblxuICBjb25zdCBsYnIgPSAodHlwZW9mIGJyYWNrZXRzWzBdID09PSAnc3RyaW5nJylcbiAgICA/IGJyYWNrZXRzWzBdXG4gICAgOiAnWyc7XG4gIGNvbnN0IHJiciA9ICh0eXBlb2YgYnJhY2tldHNbMV0gPT09ICdzdHJpbmcnKVxuICAgID8gYnJhY2tldHNbMV1cbiAgICA6ICddJztcbiAgcmV0dXJuIGxiciArIHN0ciArIHJicjtcbn1cblxuZnVuY3Rpb24gcGF0aFJld3JpdGUgKHBhdGgsIHJld3JpdGVyLCBiYXNlVXJsLCBtZXRhZGF0YSwgZWxlbSkge1xuICBjb25zdCBtb2RpZmllZFBhdGggPSAodHlwZW9mIHJld3JpdGVyID09PSAnZnVuY3Rpb24nKVxuICAgID8gcmV3cml0ZXIocGF0aCwgbWV0YWRhdGEsIGVsZW0pXG4gICAgOiBwYXRoO1xuICByZXR1cm4gKG1vZGlmaWVkUGF0aFswXSA9PT0gJy8nICYmIGJhc2VVcmwpXG4gICAgPyB0cmltQ2hhcmFjdGVyRW5kKGJhc2VVcmwsICcvJykgKyBtb2RpZmllZFBhdGhcbiAgICA6IG1vZGlmaWVkUGF0aDtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIGFuIGltYWdlLlxuICpcbiAqIEB0eXBlIHsgRm9ybWF0Q2FsbGJhY2sgfVxuICovXG5mdW5jdGlvbiBmb3JtYXRJbWFnZSAoZWxlbSwgd2FsaywgYnVpbGRlciwgZm9ybWF0T3B0aW9ucykge1xuICBjb25zdCBhdHRyaWJzID0gZWxlbS5hdHRyaWJzIHx8IHt9O1xuICBjb25zdCBhbHQgPSAoYXR0cmlicy5hbHQpXG4gICAgPyBhdHRyaWJzLmFsdFxuICAgIDogJyc7XG4gIGNvbnN0IHNyYyA9ICghYXR0cmlicy5zcmMpXG4gICAgPyAnJ1xuICAgIDogcGF0aFJld3JpdGUoYXR0cmlicy5zcmMsIGZvcm1hdE9wdGlvbnMucGF0aFJld3JpdGUsIGZvcm1hdE9wdGlvbnMuYmFzZVVybCwgYnVpbGRlci5tZXRhZGF0YSwgZWxlbSk7XG4gIGNvbnN0IHRleHQgPSAoIXNyYylcbiAgICA/IGFsdFxuICAgIDogKCFhbHQpXG4gICAgICA/IHdpdGhCcmFja2V0cyhzcmMsIGZvcm1hdE9wdGlvbnMubGlua0JyYWNrZXRzKVxuICAgICAgOiBhbHQgKyAnICcgKyB3aXRoQnJhY2tldHMoc3JjLCBmb3JtYXRPcHRpb25zLmxpbmtCcmFja2V0cyk7XG5cbiAgYnVpbGRlci5hZGRJbmxpbmUodGV4dCwgeyBub1dvcmRUcmFuc2Zvcm06IHRydWUgfSk7XG59XG5cbi8vIGEgaW1nIGJhc2VVcmxcbi8vIGEgaW1nIHBhdGhSZXdyaXRlXG4vLyBhIGltZyBsaW5rQnJhY2tldHNcblxuLy8gYSAgICAgaWdub3JlSHJlZjogZmFsc2Vcbi8vICAgICAgICAgICAgaWdub3JlVGV4dCA/XG4vLyBhICAgICBub0FuY2hvclVybDogdHJ1ZVxuLy8gICAgICAgICAgICBjYW4gYmUgcmVwbGFjZWQgd2l0aCBzZWxlY3RvclxuLy8gYSAgICAgaGlkZUxpbmtIcmVmSWZTYW1lQXNUZXh0OiBmYWxzZVxuLy8gICAgICAgICAgICBob3cgdG8gY29tcGFyZSwgd2hhdCB0byBzaG93ICh0ZXh0LCBocmVmLCBub3JtYWxpemVkKSA/XG4vLyBhICAgICBtYWlsdG8gcHJvdG9jb2wgcmVtb3ZlZCB3aXRob3V0IG9wdGlvbnNcblxuLy8gYSAgICAgcHJvdG9jb2xzOiBtYWlsdG8sIHRlbCwgLi4uXG4vLyAgICAgICAgICAgIGNhbiBiZSBtYXRjaGVkIHdpdGggc2VsZWN0b3I/XG5cbi8vIGFuY2hvcnMsIHByb3RvY29scyAtIG9ubHkgaWYgbm8gcGF0aFJld3JpdGUgZm4gaXMgcHJvdmlkZWRcblxuLy8gbm9ybWFsaXplLXVybCA/XG5cbi8vIGFcbi8vIGFbaHJlZl49XCIjXCJdIC0gZm9ybWF0OnNraXAgYnkgZGVmYXVsdFxuLy8gYVtocmVmXj1cIm1haWx0bzpcIl0gLSA/XG5cbi8qKlxuICogUHJvY2VzcyBhbiBhbmNob3IuXG4gKlxuICogQHR5cGUgeyBGb3JtYXRDYWxsYmFjayB9XG4gKi9cbmZ1bmN0aW9uIGZvcm1hdEFuY2hvciAoZWxlbSwgd2FsaywgYnVpbGRlciwgZm9ybWF0T3B0aW9ucykge1xuICBmdW5jdGlvbiBnZXRIcmVmICgpIHtcbiAgICBpZiAoZm9ybWF0T3B0aW9ucy5pZ25vcmVIcmVmKSB7IHJldHVybiAnJzsgfVxuICAgIGlmICghZWxlbS5hdHRyaWJzIHx8ICFlbGVtLmF0dHJpYnMuaHJlZikgeyByZXR1cm4gJyc7IH1cbiAgICBsZXQgaHJlZiA9IGVsZW0uYXR0cmlicy5ocmVmLnJlcGxhY2UoL15tYWlsdG86LywgJycpO1xuICAgIGlmIChmb3JtYXRPcHRpb25zLm5vQW5jaG9yVXJsICYmIGhyZWZbMF0gPT09ICcjJykgeyByZXR1cm4gJyc7IH1cbiAgICBocmVmID0gcGF0aFJld3JpdGUoaHJlZiwgZm9ybWF0T3B0aW9ucy5wYXRoUmV3cml0ZSwgZm9ybWF0T3B0aW9ucy5iYXNlVXJsLCBidWlsZGVyLm1ldGFkYXRhLCBlbGVtKTtcbiAgICByZXR1cm4gaHJlZjtcbiAgfVxuICBjb25zdCBocmVmID0gZ2V0SHJlZigpO1xuICBpZiAoIWhyZWYpIHtcbiAgICB3YWxrKGVsZW0uY2hpbGRyZW4sIGJ1aWxkZXIpO1xuICB9IGVsc2Uge1xuICAgIGxldCB0ZXh0ID0gJyc7XG4gICAgYnVpbGRlci5wdXNoV29yZFRyYW5zZm9ybShcbiAgICAgIHN0ciA9PiB7XG4gICAgICAgIGlmIChzdHIpIHsgdGV4dCArPSBzdHI7IH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH1cbiAgICApO1xuICAgIHdhbGsoZWxlbS5jaGlsZHJlbiwgYnVpbGRlcik7XG4gICAgYnVpbGRlci5wb3BXb3JkVHJhbnNmb3JtKCk7XG5cbiAgICBjb25zdCBoaWRlU2FtZUxpbmsgPSBmb3JtYXRPcHRpb25zLmhpZGVMaW5rSHJlZklmU2FtZUFzVGV4dCAmJiBocmVmID09PSB0ZXh0O1xuICAgIGlmICghaGlkZVNhbWVMaW5rKSB7XG4gICAgICBidWlsZGVyLmFkZElubGluZShcbiAgICAgICAgKCF0ZXh0KVxuICAgICAgICAgID8gaHJlZlxuICAgICAgICAgIDogJyAnICsgd2l0aEJyYWNrZXRzKGhyZWYsIGZvcm1hdE9wdGlvbnMubGlua0JyYWNrZXRzKSxcbiAgICAgICAgeyBub1dvcmRUcmFuc2Zvcm06IHRydWUgfVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0geyBEb21Ob2RlIH0gICAgICAgICAgIGVsZW0gICAgICAgICAgICAgICBMaXN0IGl0ZW1zIHdpdGggdGhlaXIgcHJlZml4ZXMuXG4gKiBAcGFyYW0geyBSZWN1cnNpdmVDYWxsYmFjayB9IHdhbGsgICAgICAgICAgICAgICBSZWN1cnNpdmUgY2FsbGJhY2sgdG8gcHJvY2VzcyBjaGlsZCBub2Rlcy5cbiAqIEBwYXJhbSB7IEJsb2NrVGV4dEJ1aWxkZXIgfSAgYnVpbGRlciAgICAgICAgICAgIFBhc3NlZCBhcm91bmQgdG8gYWNjdW11bGF0ZSBvdXRwdXQgdGV4dC5cbiAqIEBwYXJhbSB7IEZvcm1hdE9wdGlvbnMgfSAgICAgZm9ybWF0T3B0aW9ucyAgICAgIE9wdGlvbnMgc3BlY2lmaWMgdG8gYSBmb3JtYXR0ZXIuXG4gKiBAcGFyYW0geyAoKSA9PiBzdHJpbmcgfSAgICAgIG5leHRQcmVmaXhDYWxsYmFjayBGdW5jdGlvbiB0aGF0IHJldHVybnMgaW5jcmVhc2luZyBpbmRleCBlYWNoIHRpbWUgaXQgaXMgY2FsbGVkLlxuICovXG5mdW5jdGlvbiBmb3JtYXRMaXN0IChlbGVtLCB3YWxrLCBidWlsZGVyLCBmb3JtYXRPcHRpb25zLCBuZXh0UHJlZml4Q2FsbGJhY2spIHtcbiAgY29uc3QgaXNOZXN0ZWRMaXN0ID0gZ2V0KGVsZW0sIFsncGFyZW50JywgJ25hbWUnXSkgPT09ICdsaSc7XG5cbiAgLy8gV2l0aCBSb21hbiBudW1iZXJzLCBpbmRleCBsZW5ndGggaXMgbm90IGFzIHN0cmFpZ2h0Zm9yd2FyZCBhcyB3aXRoIEFyYWJpYyBudW1iZXJzIG9yIGxldHRlcnMsXG4gIC8vIHNvIHRoZSBkdW1iIGxlbmd0aCBjb21wYXJpc29uIGlzIHRoZSBtb3N0IHJvYnVzdCB3YXkgdG8gZ2V0IHRoZSBjb3JyZWN0IHZhbHVlLlxuICBsZXQgbWF4UHJlZml4TGVuZ3RoID0gMDtcbiAgY29uc3QgbGlzdEl0ZW1zID0gKGVsZW0uY2hpbGRyZW4gfHwgW10pXG4gICAgLy8gaXQgbWlnaHQgYmUgbW9yZSBhY2N1cmF0ZSB0byBjaGVjayBvbmx5IGZvciBodG1sIHNwYWNlcyBoZXJlLCBidXQgbm8gc2lnbmlmaWNhbnQgYmVuZWZpdFxuICAgIC5maWx0ZXIoY2hpbGQgPT4gY2hpbGQudHlwZSAhPT0gJ3RleHQnIHx8ICEvXlxccyokLy50ZXN0KGNoaWxkLmRhdGEpKVxuICAgIC5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQubmFtZSAhPT0gJ2xpJykge1xuICAgICAgICByZXR1cm4geyBub2RlOiBjaGlsZCwgcHJlZml4OiAnJyB9O1xuICAgICAgfVxuICAgICAgY29uc3QgcHJlZml4ID0gKGlzTmVzdGVkTGlzdClcbiAgICAgICAgPyBuZXh0UHJlZml4Q2FsbGJhY2soKS50cmltU3RhcnQoKVxuICAgICAgICA6IG5leHRQcmVmaXhDYWxsYmFjaygpO1xuICAgICAgaWYgKHByZWZpeC5sZW5ndGggPiBtYXhQcmVmaXhMZW5ndGgpIHsgbWF4UHJlZml4TGVuZ3RoID0gcHJlZml4Lmxlbmd0aDsgfVxuICAgICAgcmV0dXJuIHsgbm9kZTogY2hpbGQsIHByZWZpeDogcHJlZml4IH07XG4gICAgfSk7XG4gIGlmICghbGlzdEl0ZW1zLmxlbmd0aCkgeyByZXR1cm47IH1cblxuICBidWlsZGVyLm9wZW5MaXN0KHtcbiAgICBpbnRlclJvd0xpbmVCcmVha3M6IDEsXG4gICAgbGVhZGluZ0xpbmVCcmVha3M6IGlzTmVzdGVkTGlzdCA/IDEgOiAoZm9ybWF0T3B0aW9ucy5sZWFkaW5nTGluZUJyZWFrcyB8fCAyKSxcbiAgICBtYXhQcmVmaXhMZW5ndGg6IG1heFByZWZpeExlbmd0aCxcbiAgICBwcmVmaXhBbGlnbjogJ2xlZnQnXG4gIH0pO1xuXG4gIGZvciAoY29uc3QgeyBub2RlLCBwcmVmaXggfSBvZiBsaXN0SXRlbXMpIHtcbiAgICBidWlsZGVyLm9wZW5MaXN0SXRlbSh7IHByZWZpeDogcHJlZml4IH0pO1xuICAgIHdhbGsoW25vZGVdLCBidWlsZGVyKTtcbiAgICBidWlsZGVyLmNsb3NlTGlzdEl0ZW0oKTtcbiAgfVxuXG4gIGJ1aWxkZXIuY2xvc2VMaXN0KHsgdHJhaWxpbmdMaW5lQnJlYWtzOiBpc05lc3RlZExpc3QgPyAxIDogKGZvcm1hdE9wdGlvbnMudHJhaWxpbmdMaW5lQnJlYWtzIHx8IDIpIH0pO1xufVxuXG4vKipcbiAqIFByb2Nlc3MgYW4gdW5vcmRlcmVkIGxpc3QuXG4gKlxuICogQHR5cGUgeyBGb3JtYXRDYWxsYmFjayB9XG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFVub3JkZXJlZExpc3QgKGVsZW0sIHdhbGssIGJ1aWxkZXIsIGZvcm1hdE9wdGlvbnMpIHtcbiAgY29uc3QgcHJlZml4ID0gZm9ybWF0T3B0aW9ucy5pdGVtUHJlZml4IHx8ICcgKiAnO1xuICByZXR1cm4gZm9ybWF0TGlzdChlbGVtLCB3YWxrLCBidWlsZGVyLCBmb3JtYXRPcHRpb25zLCAoKSA9PiBwcmVmaXgpO1xufVxuXG4vKipcbiAqIFByb2Nlc3MgYW4gb3JkZXJlZCBsaXN0LlxuICpcbiAqIEB0eXBlIHsgRm9ybWF0Q2FsbGJhY2sgfVxuICovXG5mdW5jdGlvbiBmb3JtYXRPcmRlcmVkTGlzdCAoZWxlbSwgd2FsaywgYnVpbGRlciwgZm9ybWF0T3B0aW9ucykge1xuICBsZXQgbmV4dEluZGV4ID0gTnVtYmVyKGVsZW0uYXR0cmlicy5zdGFydCB8fCAnMScpO1xuICBjb25zdCBpbmRleEZ1bmN0aW9uID0gZ2V0T3JkZXJlZExpc3RJbmRleEZ1bmN0aW9uKGVsZW0uYXR0cmlicy50eXBlKTtcbiAgY29uc3QgbmV4dFByZWZpeENhbGxiYWNrID0gKCkgPT4gJyAnICsgaW5kZXhGdW5jdGlvbihuZXh0SW5kZXgrKykgKyAnLiAnO1xuICByZXR1cm4gZm9ybWF0TGlzdChlbGVtLCB3YWxrLCBidWlsZGVyLCBmb3JtYXRPcHRpb25zLCBuZXh0UHJlZml4Q2FsbGJhY2spO1xufVxuXG4vKipcbiAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gZ2VuZXJhdGUgaW5kZXggbWFya2VycyBvZiBhIHNwZWNpZmllZCBmb3JtYXQuXG4gKlxuICogQHBhcmFtICAgeyBzdHJpbmcgfSBbb2xUeXBlPScxJ10gTWFya2VyIHR5cGUuXG4gKiBAcmV0dXJucyB7IChpOiBudW1iZXIpID0+IHN0cmluZyB9XG4gKi9cbmZ1bmN0aW9uIGdldE9yZGVyZWRMaXN0SW5kZXhGdW5jdGlvbiAob2xUeXBlID0gJzEnKSB7XG4gIHN3aXRjaCAob2xUeXBlKSB7XG4gICAgY2FzZSAnYSc6IHJldHVybiAoaSkgPT4gbnVtYmVyVG9MZXR0ZXJTZXF1ZW5jZShpLCAnYScpO1xuICAgIGNhc2UgJ0EnOiByZXR1cm4gKGkpID0+IG51bWJlclRvTGV0dGVyU2VxdWVuY2UoaSwgJ0EnKTtcbiAgICBjYXNlICdpJzogcmV0dXJuIChpKSA9PiBudW1iZXJUb1JvbWFuKGkpLnRvTG93ZXJDYXNlKCk7XG4gICAgY2FzZSAnSSc6IHJldHVybiAoaSkgPT4gbnVtYmVyVG9Sb21hbihpKTtcbiAgICBjYXNlICcxJzpcbiAgICBkZWZhdWx0OiByZXR1cm4gKGkpID0+IChpKS50b1N0cmluZygpO1xuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYSBsaXN0IG9mIGNsYXNzIGFuZCBJRCBzZWxlY3RvcnMgKHByZWZpeGVkIHdpdGggJy4nIGFuZCAnIycpLFxuICogcmV0dXJuIHRoZW0gYXMgc2VwYXJhdGUgbGlzdHMgb2YgbmFtZXMgd2l0aG91dCBwcmVmaXhlcy5cbiAqXG4gKiBAcGFyYW0geyBzdHJpbmdbXSB9IHNlbGVjdG9ycyBDbGFzcyBhbmQgSUQgc2VsZWN0b3JzIChgW1wiLmNsYXNzXCIsIFwiI2lkXCJdYCBldGMpLlxuICogQHJldHVybnMgeyB7IGNsYXNzZXM6IHN0cmluZ1tdLCBpZHM6IHN0cmluZ1tdIH0gfVxuICovXG5mdW5jdGlvbiBzcGxpdENsYXNzZXNBbmRJZHMgKHNlbGVjdG9ycykge1xuICBjb25zdCBjbGFzc2VzID0gW107XG4gIGNvbnN0IGlkcyA9IFtdO1xuICBmb3IgKGNvbnN0IHNlbGVjdG9yIG9mIHNlbGVjdG9ycykge1xuICAgIGlmIChzZWxlY3Rvci5zdGFydHNXaXRoKCcuJykpIHtcbiAgICAgIGNsYXNzZXMucHVzaChzZWxlY3Rvci5zdWJzdHJpbmcoMSkpO1xuICAgIH0gZWxzZSBpZiAoc2VsZWN0b3Iuc3RhcnRzV2l0aCgnIycpKSB7XG4gICAgICBpZHMucHVzaChzZWxlY3Rvci5zdWJzdHJpbmcoMSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBjbGFzc2VzOiBjbGFzc2VzLCBpZHM6IGlkcyB9O1xufVxuXG5mdW5jdGlvbiBpc0RhdGFUYWJsZSAoYXR0ciwgdGFibGVzKSB7XG4gIGlmICh0YWJsZXMgPT09IHRydWUpIHsgcmV0dXJuIHRydWU7IH1cbiAgaWYgKCFhdHRyKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGNvbnN0IHsgY2xhc3NlcywgaWRzIH0gPSBzcGxpdENsYXNzZXNBbmRJZHModGFibGVzKTtcbiAgY29uc3QgYXR0ckNsYXNzZXMgPSAoYXR0clsnY2xhc3MnXSB8fCAnJykuc3BsaXQoJyAnKTtcbiAgY29uc3QgYXR0cklkcyA9IChhdHRyWydpZCddIHx8ICcnKS5zcGxpdCgnICcpO1xuXG4gIHJldHVybiBhdHRyQ2xhc3Nlcy5zb21lKHggPT4gY2xhc3Nlcy5pbmNsdWRlcyh4KSkgfHwgYXR0cklkcy5zb21lKHggPT4gaWRzLmluY2x1ZGVzKHgpKTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIGEgdGFibGUgKGVpdGhlciBhcyBhIGNvbnRhaW5lciBvciBhcyBhIGRhdGEgdGFibGUsIGRlcGVuZGluZyBvbiBvcHRpb25zKS5cbiAqXG4gKiBAdHlwZSB7IEZvcm1hdENhbGxiYWNrIH1cbiAqL1xuZnVuY3Rpb24gZm9ybWF0VGFibGUgKGVsZW0sIHdhbGssIGJ1aWxkZXIsIGZvcm1hdE9wdGlvbnMpIHtcbiAgcmV0dXJuIGlzRGF0YVRhYmxlKGVsZW0uYXR0cmlicywgYnVpbGRlci5vcHRpb25zLnRhYmxlcylcbiAgICA/IGZvcm1hdERhdGFUYWJsZShlbGVtLCB3YWxrLCBidWlsZGVyLCBmb3JtYXRPcHRpb25zKVxuICAgIDogZm9ybWF0QmxvY2soZWxlbSwgd2FsaywgYnVpbGRlciwgZm9ybWF0T3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEJsb2NrIChlbGVtLCB3YWxrLCBidWlsZGVyLCBmb3JtYXRPcHRpb25zKSB7XG4gIGJ1aWxkZXIub3BlbkJsb2NrKHsgbGVhZGluZ0xpbmVCcmVha3M6IGZvcm1hdE9wdGlvbnMubGVhZGluZ0xpbmVCcmVha3MgfSk7XG4gIHdhbGsoZWxlbS5jaGlsZHJlbiwgYnVpbGRlcik7XG4gIGJ1aWxkZXIuY2xvc2VCbG9jayh7IHRyYWlsaW5nTGluZUJyZWFrczogZm9ybWF0T3B0aW9ucy50cmFpbGluZ0xpbmVCcmVha3MgfSk7XG59XG5cbi8qKlxuICogUHJvY2VzcyBhIGRhdGEgdGFibGUuXG4gKlxuICogQHR5cGUgeyBGb3JtYXRDYWxsYmFjayB9XG4gKi9cbmZ1bmN0aW9uIGZvcm1hdERhdGFUYWJsZSAoZWxlbSwgd2FsaywgYnVpbGRlciwgZm9ybWF0T3B0aW9ucykge1xuICBidWlsZGVyLm9wZW5UYWJsZSgpO1xuICBlbGVtLmNoaWxkcmVuLmZvckVhY2god2Fsa1RhYmxlKTtcbiAgYnVpbGRlci5jbG9zZVRhYmxlKHtcbiAgICB0YWJsZVRvU3RyaW5nOiAocm93cykgPT4gdGFibGVUb1N0cmluZyhyb3dzLCBmb3JtYXRPcHRpb25zLnJvd1NwYWNpbmcgPz8gMCwgZm9ybWF0T3B0aW9ucy5jb2xTcGFjaW5nID8/IDMpLFxuICAgIGxlYWRpbmdMaW5lQnJlYWtzOiBmb3JtYXRPcHRpb25zLmxlYWRpbmdMaW5lQnJlYWtzLFxuICAgIHRyYWlsaW5nTGluZUJyZWFrczogZm9ybWF0T3B0aW9ucy50cmFpbGluZ0xpbmVCcmVha3NcbiAgfSk7XG5cbiAgZnVuY3Rpb24gZm9ybWF0Q2VsbCAoY2VsbE5vZGUpIHtcbiAgICBjb25zdCBjb2xzcGFuID0gK2dldChjZWxsTm9kZSwgWydhdHRyaWJzJywgJ2NvbHNwYW4nXSkgfHwgMTtcbiAgICBjb25zdCByb3dzcGFuID0gK2dldChjZWxsTm9kZSwgWydhdHRyaWJzJywgJ3Jvd3NwYW4nXSkgfHwgMTtcbiAgICBidWlsZGVyLm9wZW5UYWJsZUNlbGwoeyBtYXhDb2x1bW5XaWR0aDogZm9ybWF0T3B0aW9ucy5tYXhDb2x1bW5XaWR0aCB9KTtcbiAgICB3YWxrKGNlbGxOb2RlLmNoaWxkcmVuLCBidWlsZGVyKTtcbiAgICBidWlsZGVyLmNsb3NlVGFibGVDZWxsKHsgY29sc3BhbjogY29sc3Bhbiwgcm93c3Bhbjogcm93c3BhbiB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhbGtUYWJsZSAoZWxlbSkge1xuICAgIGlmIChlbGVtLnR5cGUgIT09ICd0YWcnKSB7IHJldHVybjsgfVxuXG4gICAgY29uc3QgZm9ybWF0SGVhZGVyQ2VsbCA9IChmb3JtYXRPcHRpb25zLnVwcGVyY2FzZUhlYWRlckNlbGxzICE9PSBmYWxzZSlcbiAgICAgID8gKGNlbGxOb2RlKSA9PiB7XG4gICAgICAgIGJ1aWxkZXIucHVzaFdvcmRUcmFuc2Zvcm0oc3RyID0+IHN0ci50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgZm9ybWF0Q2VsbChjZWxsTm9kZSk7XG4gICAgICAgIGJ1aWxkZXIucG9wV29yZFRyYW5zZm9ybSgpO1xuICAgICAgfVxuICAgICAgOiBmb3JtYXRDZWxsO1xuXG4gICAgc3dpdGNoIChlbGVtLm5hbWUpIHtcbiAgICAgIGNhc2UgJ3RoZWFkJzpcbiAgICAgIGNhc2UgJ3Rib2R5JzpcbiAgICAgIGNhc2UgJ3Rmb290JzpcbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgIGVsZW0uY2hpbGRyZW4uZm9yRWFjaCh3YWxrVGFibGUpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgJ3RyJzoge1xuICAgICAgICBidWlsZGVyLm9wZW5UYWJsZVJvdygpO1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkT2ZUciBvZiBlbGVtLmNoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKGNoaWxkT2ZUci50eXBlICE9PSAndGFnJykgeyBjb250aW51ZTsgfVxuICAgICAgICAgIHN3aXRjaCAoY2hpbGRPZlRyLm5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3RoJzoge1xuICAgICAgICAgICAgICBmb3JtYXRIZWFkZXJDZWxsKGNoaWxkT2ZUcik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAndGQnOiB7XG4gICAgICAgICAgICAgIGZvcm1hdENlbGwoY2hpbGRPZlRyKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnVpbGRlci5jbG9zZVRhYmxlUm93KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgfVxuICB9XG59XG5cbnZhciB0ZXh0Rm9ybWF0dGVycyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBhbmNob3I6IGZvcm1hdEFuY2hvcixcbiAgYmxvY2txdW90ZTogZm9ybWF0QmxvY2txdW90ZSxcbiAgZGF0YVRhYmxlOiBmb3JtYXREYXRhVGFibGUsXG4gIGhlYWRpbmc6IGZvcm1hdEhlYWRpbmcsXG4gIGhvcml6b250YWxMaW5lOiBmb3JtYXRIb3Jpem9udGFsTGluZSxcbiAgaW1hZ2U6IGZvcm1hdEltYWdlLFxuICBsaW5lQnJlYWs6IGZvcm1hdExpbmVCcmVhayxcbiAgb3JkZXJlZExpc3Q6IGZvcm1hdE9yZGVyZWRMaXN0LFxuICBwYXJhZ3JhcGg6IGZvcm1hdFBhcmFncmFwaCxcbiAgcHJlOiBmb3JtYXRQcmUsXG4gIHRhYmxlOiBmb3JtYXRUYWJsZSxcbiAgdW5vcmRlcmVkTGlzdDogZm9ybWF0VW5vcmRlcmVkTGlzdCxcbiAgd2JyOiBmb3JtYXRXYnJcbn0pO1xuXG4vKipcbiAqIERlZmF1bHQgb3B0aW9ucy5cbiAqXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHsgT3B0aW9ucyB9XG4gKiBAZGVmYXVsdFxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgREVGQVVMVF9PUFRJT05TID0ge1xuICBiYXNlRWxlbWVudHM6IHtcbiAgICBzZWxlY3RvcnM6IFsgJ2JvZHknIF0sXG4gICAgb3JkZXJCeTogJ3NlbGVjdG9ycycsIC8vICdzZWxlY3RvcnMnIHwgJ29jY3VycmVuY2UnXG4gICAgcmV0dXJuRG9tQnlEZWZhdWx0OiB0cnVlXG4gIH0sXG4gIGRlY29kZUVudGl0aWVzOiB0cnVlLFxuICBlbmNvZGVDaGFyYWN0ZXJzOiB7fSxcbiAgZm9ybWF0dGVyczoge30sXG4gIGxpbWl0czoge1xuICAgIGVsbGlwc2lzOiAnLi4uJyxcbiAgICBtYXhCYXNlRWxlbWVudHM6IHVuZGVmaW5lZCxcbiAgICBtYXhDaGlsZE5vZGVzOiB1bmRlZmluZWQsXG4gICAgbWF4RGVwdGg6IHVuZGVmaW5lZCxcbiAgICBtYXhJbnB1dExlbmd0aDogKDEgPDwgMjQpIC8vIDE2Xzc3N18yMTZcbiAgfSxcbiAgbG9uZ1dvcmRTcGxpdDoge1xuICAgIGZvcmNlV3JhcE9uTGltaXQ6IGZhbHNlLFxuICAgIHdyYXBDaGFyYWN0ZXJzOiBbXVxuICB9LFxuICBwcmVzZXJ2ZU5ld2xpbmVzOiBmYWxzZSxcbiAgc2VsZWN0b3JzOiBbXG4gICAgeyBzZWxlY3RvcjogJyonLCBmb3JtYXQ6ICdpbmxpbmUnIH0sXG4gICAge1xuICAgICAgc2VsZWN0b3I6ICdhJyxcbiAgICAgIGZvcm1hdDogJ2FuY2hvcicsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGJhc2VVcmw6IG51bGwsXG4gICAgICAgIGhpZGVMaW5rSHJlZklmU2FtZUFzVGV4dDogZmFsc2UsXG4gICAgICAgIGlnbm9yZUhyZWY6IGZhbHNlLFxuICAgICAgICBsaW5rQnJhY2tldHM6IFsnWycsICddJ10sXG4gICAgICAgIG5vQW5jaG9yVXJsOiB0cnVlXG4gICAgICB9XG4gICAgfSxcbiAgICB7IHNlbGVjdG9yOiAnYXJ0aWNsZScsIGZvcm1hdDogJ2Jsb2NrJywgb3B0aW9uczogeyBsZWFkaW5nTGluZUJyZWFrczogMSwgdHJhaWxpbmdMaW5lQnJlYWtzOiAxIH0gfSxcbiAgICB7IHNlbGVjdG9yOiAnYXNpZGUnLCBmb3JtYXQ6ICdibG9jaycsIG9wdGlvbnM6IHsgbGVhZGluZ0xpbmVCcmVha3M6IDEsIHRyYWlsaW5nTGluZUJyZWFrczogMSB9IH0sXG4gICAge1xuICAgICAgc2VsZWN0b3I6ICdibG9ja3F1b3RlJyxcbiAgICAgIGZvcm1hdDogJ2Jsb2NrcXVvdGUnLFxuICAgICAgb3B0aW9uczogeyBsZWFkaW5nTGluZUJyZWFrczogMiwgdHJhaWxpbmdMaW5lQnJlYWtzOiAyLCB0cmltRW1wdHlMaW5lczogdHJ1ZSB9XG4gICAgfSxcbiAgICB7IHNlbGVjdG9yOiAnYnInLCBmb3JtYXQ6ICdsaW5lQnJlYWsnIH0sXG4gICAgeyBzZWxlY3RvcjogJ2RpdicsIGZvcm1hdDogJ2Jsb2NrJywgb3B0aW9uczogeyBsZWFkaW5nTGluZUJyZWFrczogMSwgdHJhaWxpbmdMaW5lQnJlYWtzOiAxIH0gfSxcbiAgICB7IHNlbGVjdG9yOiAnZm9vdGVyJywgZm9ybWF0OiAnYmxvY2snLCBvcHRpb25zOiB7IGxlYWRpbmdMaW5lQnJlYWtzOiAxLCB0cmFpbGluZ0xpbmVCcmVha3M6IDEgfSB9LFxuICAgIHsgc2VsZWN0b3I6ICdmb3JtJywgZm9ybWF0OiAnYmxvY2snLCBvcHRpb25zOiB7IGxlYWRpbmdMaW5lQnJlYWtzOiAxLCB0cmFpbGluZ0xpbmVCcmVha3M6IDEgfSB9LFxuICAgIHsgc2VsZWN0b3I6ICdoMScsIGZvcm1hdDogJ2hlYWRpbmcnLCBvcHRpb25zOiB7IGxlYWRpbmdMaW5lQnJlYWtzOiAzLCB0cmFpbGluZ0xpbmVCcmVha3M6IDIsIHVwcGVyY2FzZTogdHJ1ZSB9IH0sXG4gICAgeyBzZWxlY3RvcjogJ2gyJywgZm9ybWF0OiAnaGVhZGluZycsIG9wdGlvbnM6IHsgbGVhZGluZ0xpbmVCcmVha3M6IDMsIHRyYWlsaW5nTGluZUJyZWFrczogMiwgdXBwZXJjYXNlOiB0cnVlIH0gfSxcbiAgICB7IHNlbGVjdG9yOiAnaDMnLCBmb3JtYXQ6ICdoZWFkaW5nJywgb3B0aW9uczogeyBsZWFkaW5nTGluZUJyZWFrczogMywgdHJhaWxpbmdMaW5lQnJlYWtzOiAyLCB1cHBlcmNhc2U6IHRydWUgfSB9LFxuICAgIHsgc2VsZWN0b3I6ICdoNCcsIGZvcm1hdDogJ2hlYWRpbmcnLCBvcHRpb25zOiB7IGxlYWRpbmdMaW5lQnJlYWtzOiAyLCB0cmFpbGluZ0xpbmVCcmVha3M6IDIsIHVwcGVyY2FzZTogdHJ1ZSB9IH0sXG4gICAgeyBzZWxlY3RvcjogJ2g1JywgZm9ybWF0OiAnaGVhZGluZycsIG9wdGlvbnM6IHsgbGVhZGluZ0xpbmVCcmVha3M6IDIsIHRyYWlsaW5nTGluZUJyZWFrczogMiwgdXBwZXJjYXNlOiB0cnVlIH0gfSxcbiAgICB7IHNlbGVjdG9yOiAnaDYnLCBmb3JtYXQ6ICdoZWFkaW5nJywgb3B0aW9uczogeyBsZWFkaW5nTGluZUJyZWFrczogMiwgdHJhaWxpbmdMaW5lQnJlYWtzOiAyLCB1cHBlcmNhc2U6IHRydWUgfSB9LFxuICAgIHsgc2VsZWN0b3I6ICdoZWFkZXInLCBmb3JtYXQ6ICdibG9jaycsIG9wdGlvbnM6IHsgbGVhZGluZ0xpbmVCcmVha3M6IDEsIHRyYWlsaW5nTGluZUJyZWFrczogMSB9IH0sXG4gICAge1xuICAgICAgc2VsZWN0b3I6ICdocicsXG4gICAgICBmb3JtYXQ6ICdob3Jpem9udGFsTGluZScsXG4gICAgICBvcHRpb25zOiB7IGxlYWRpbmdMaW5lQnJlYWtzOiAyLCBsZW5ndGg6IHVuZGVmaW5lZCwgdHJhaWxpbmdMaW5lQnJlYWtzOiAyIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIHNlbGVjdG9yOiAnaW1nJyxcbiAgICAgIGZvcm1hdDogJ2ltYWdlJyxcbiAgICAgIG9wdGlvbnM6IHsgYmFzZVVybDogbnVsbCwgbGlua0JyYWNrZXRzOiBbJ1snLCAnXSddIH1cbiAgICB9LFxuICAgIHsgc2VsZWN0b3I6ICdtYWluJywgZm9ybWF0OiAnYmxvY2snLCBvcHRpb25zOiB7IGxlYWRpbmdMaW5lQnJlYWtzOiAxLCB0cmFpbGluZ0xpbmVCcmVha3M6IDEgfSB9LFxuICAgIHsgc2VsZWN0b3I6ICduYXYnLCBmb3JtYXQ6ICdibG9jaycsIG9wdGlvbnM6IHsgbGVhZGluZ0xpbmVCcmVha3M6IDEsIHRyYWlsaW5nTGluZUJyZWFrczogMSB9IH0sXG4gICAge1xuICAgICAgc2VsZWN0b3I6ICdvbCcsXG4gICAgICBmb3JtYXQ6ICdvcmRlcmVkTGlzdCcsXG4gICAgICBvcHRpb25zOiB7IGxlYWRpbmdMaW5lQnJlYWtzOiAyLCB0cmFpbGluZ0xpbmVCcmVha3M6IDIgfVxuICAgIH0sXG4gICAgeyBzZWxlY3RvcjogJ3AnLCBmb3JtYXQ6ICdwYXJhZ3JhcGgnLCBvcHRpb25zOiB7IGxlYWRpbmdMaW5lQnJlYWtzOiAyLCB0cmFpbGluZ0xpbmVCcmVha3M6IDIgfSB9LFxuICAgIHsgc2VsZWN0b3I6ICdwcmUnLCBmb3JtYXQ6ICdwcmUnLCBvcHRpb25zOiB7IGxlYWRpbmdMaW5lQnJlYWtzOiAyLCB0cmFpbGluZ0xpbmVCcmVha3M6IDIgfSB9LFxuICAgIHsgc2VsZWN0b3I6ICdzZWN0aW9uJywgZm9ybWF0OiAnYmxvY2snLCBvcHRpb25zOiB7IGxlYWRpbmdMaW5lQnJlYWtzOiAxLCB0cmFpbGluZ0xpbmVCcmVha3M6IDEgfSB9LFxuICAgIHtcbiAgICAgIHNlbGVjdG9yOiAndGFibGUnLFxuICAgICAgZm9ybWF0OiAndGFibGUnLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBjb2xTcGFjaW5nOiAzLFxuICAgICAgICBsZWFkaW5nTGluZUJyZWFrczogMixcbiAgICAgICAgbWF4Q29sdW1uV2lkdGg6IDYwLFxuICAgICAgICByb3dTcGFjaW5nOiAwLFxuICAgICAgICB0cmFpbGluZ0xpbmVCcmVha3M6IDIsXG4gICAgICAgIHVwcGVyY2FzZUhlYWRlckNlbGxzOiB0cnVlXG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBzZWxlY3RvcjogJ3VsJyxcbiAgICAgIGZvcm1hdDogJ3Vub3JkZXJlZExpc3QnLFxuICAgICAgb3B0aW9uczogeyBpdGVtUHJlZml4OiAnICogJywgbGVhZGluZ0xpbmVCcmVha3M6IDIsIHRyYWlsaW5nTGluZUJyZWFrczogMiB9XG4gICAgfSxcbiAgICB7IHNlbGVjdG9yOiAnd2JyJywgZm9ybWF0OiAnd2JyJyB9LFxuICBdLFxuICB0YWJsZXM6IFtdLCAvLyBkZXByZWNhdGVkXG4gIHdoaXRlc3BhY2VDaGFyYWN0ZXJzOiAnIFxcdFxcclxcblxcZlxcdTIwMGInLFxuICB3b3Jkd3JhcDogODBcbn07XG5cbmNvbnN0IGNvbmNhdE1lcmdlID0gKGFjYywgc3JjLCBvcHRpb25zKSA9PiBbLi4uYWNjLCAuLi5zcmNdO1xuY29uc3Qgb3ZlcndyaXRlTWVyZ2UgPSAoYWNjLCBzcmMsIG9wdGlvbnMpID0+IFsuLi5zcmNdO1xuY29uc3Qgc2VsZWN0b3JzTWVyZ2UgPSAoYWNjLCBzcmMsIG9wdGlvbnMpID0+IChcbiAgKGFjYy5zb21lKHMgPT4gdHlwZW9mIHMgPT09ICdvYmplY3QnKSlcbiAgICA/IGNvbmNhdE1lcmdlKGFjYywgc3JjKSAvLyBzZWxlY3RvcnNcbiAgICA6IG92ZXJ3cml0ZU1lcmdlKGFjYywgc3JjKSAvLyBiYXNlRWxlbWVudHMuc2VsZWN0b3JzXG4pO1xuXG4vKipcbiAqIFByZXByb2Nlc3Mgb3B0aW9ucywgY29tcGlsZSBzZWxlY3RvcnMgaW50byBhIGRlY2lzaW9uIHRyZWUsXG4gKiByZXR1cm4gYSBmdW5jdGlvbiBpbnRlbmRlZCBmb3IgYmF0Y2ggcHJvY2Vzc2luZy5cbiAqXG4gKiBAcGFyYW0gICB7IE9wdGlvbnMgfSBbb3B0aW9ucyA9IHt9XSAgIEh0bWxUb1RleHQgb3B0aW9ucy5cbiAqIEByZXR1cm5zIHsgKGh0bWw6IHN0cmluZywgbWV0YWRhdGE/OiBhbnkpID0+IHN0cmluZyB9IFByZS1jb25maWd1cmVkIGNvbnZlcnRlciBmdW5jdGlvbi5cbiAqIEBzdGF0aWNcbiAqL1xuZnVuY3Rpb24gY29tcGlsZSAob3B0aW9ucyA9IHt9KSB7XG4gIG9wdGlvbnMgPSBtZXJnZV9fZGVmYXVsdFtcImRlZmF1bHRcIl0oXG4gICAgREVGQVVMVF9PUFRJT05TLFxuICAgIG9wdGlvbnMsXG4gICAge1xuICAgICAgYXJyYXlNZXJnZTogb3ZlcndyaXRlTWVyZ2UsXG4gICAgICBjdXN0b21NZXJnZTogKGtleSkgPT4gKChrZXkgPT09ICdzZWxlY3RvcnMnKSA/IHNlbGVjdG9yc01lcmdlIDogdW5kZWZpbmVkKVxuICAgIH1cbiAgKTtcbiAgb3B0aW9ucy5mb3JtYXR0ZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgZ2VuZXJpY0Zvcm1hdHRlcnMsIHRleHRGb3JtYXR0ZXJzLCBvcHRpb25zLmZvcm1hdHRlcnMpO1xuICBvcHRpb25zLnNlbGVjdG9ycyA9IG1lcmdlRHVwbGljYXRlc1ByZWZlckxhc3Qob3B0aW9ucy5zZWxlY3RvcnMsIChzID0+IHMuc2VsZWN0b3IpKTtcblxuICBoYW5kbGVEZXByZWNhdGVkT3B0aW9ucyhvcHRpb25zKTtcblxuICByZXR1cm4gY29tcGlsZSQxKG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIENvbnZlcnQgZ2l2ZW4gSFRNTCBjb250ZW50IHRvIHBsYWluIHRleHQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSAgIHsgc3RyaW5nIH0gIGh0bWwgICAgICAgICAgIEhUTUwgY29udGVudCB0byBjb252ZXJ0LlxuICogQHBhcmFtICAgeyBPcHRpb25zIH0gW29wdGlvbnMgPSB7fV0gSHRtbFRvVGV4dCBvcHRpb25zLlxuICogQHBhcmFtICAgeyBhbnkgfSAgICAgW21ldGFkYXRhXSAgICAgT3B0aW9uYWwgbWV0YWRhdGEgZm9yIEhUTUwgZG9jdW1lbnQsIGZvciB1c2UgaW4gZm9ybWF0dGVycy5cbiAqIEByZXR1cm5zIHsgc3RyaW5nIH0gICAgICAgICAgICAgICAgIFBsYWluIHRleHQgc3RyaW5nLlxuICogQHN0YXRpY1xuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCB7IGNvbnZlcnQgfSA9IHJlcXVpcmUoJ2h0bWwtdG8tdGV4dCcpO1xuICogY29uc3QgdGV4dCA9IGNvbnZlcnQoJzxoMT5IZWxsbyBXb3JsZDwvaDE+Jywge1xuICogICB3b3Jkd3JhcDogMTMwXG4gKiB9KTtcbiAqIGNvbnNvbGUubG9nKHRleHQpOyAvLyBIRUxMTyBXT1JMRFxuICovXG5mdW5jdGlvbiBjb252ZXJ0IChodG1sLCBvcHRpb25zID0ge30sIG1ldGFkYXRhID0gdW5kZWZpbmVkKSB7XG4gIHJldHVybiBjb21waWxlKG9wdGlvbnMpKGh0bWwsIG1ldGFkYXRhKTtcbn1cblxuLyoqXG4gKiBNYXAgcHJldmlvdXNseSBleGlzdGluZyBhbmQgbm93IGRlcHJlY2F0ZWQgb3B0aW9ucyB0byB0aGUgbmV3IG9wdGlvbnMgbGF5b3V0LlxuICogVGhpcyBpcyBhIHN1YmplY3QgZm9yIGNsZWFudXAgaW4gbWFqb3IgcmVsZWFzZXMuXG4gKlxuICogQHBhcmFtIHsgT3B0aW9ucyB9IG9wdGlvbnMgSHRtbFRvVGV4dCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBoYW5kbGVEZXByZWNhdGVkT3B0aW9ucyAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy50YWdzKSB7XG4gICAgY29uc3QgdGFnRGVmaW5pdGlvbnMgPSBPYmplY3QuZW50cmllcyhvcHRpb25zLnRhZ3MpLm1hcChcbiAgICAgIChbc2VsZWN0b3IsIGRlZmluaXRpb25dKSA9PiAoeyAuLi5kZWZpbml0aW9uLCBzZWxlY3Rvcjogc2VsZWN0b3IgfHwgJyonIH0pXG4gICAgKTtcbiAgICBvcHRpb25zLnNlbGVjdG9ycy5wdXNoKC4uLnRhZ0RlZmluaXRpb25zKTtcbiAgICBvcHRpb25zLnNlbGVjdG9ycyA9IG1lcmdlRHVwbGljYXRlc1ByZWZlckxhc3Qob3B0aW9ucy5zZWxlY3RvcnMsIChzID0+IHMuc2VsZWN0b3IpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldCAob2JqLCBwYXRoLCB2YWx1ZSkge1xuICAgIGNvbnN0IHZhbHVlS2V5ID0gcGF0aC5wb3AoKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBwYXRoKSB7XG4gICAgICBsZXQgbmVzdGVkID0gb2JqW2tleV07XG4gICAgICBpZiAoIW5lc3RlZCkge1xuICAgICAgICBuZXN0ZWQgPSB7fTtcbiAgICAgICAgb2JqW2tleV0gPSBuZXN0ZWQ7XG4gICAgICB9XG4gICAgICBvYmogPSBuZXN0ZWQ7XG4gICAgfVxuICAgIG9ialt2YWx1ZUtleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIGlmIChvcHRpb25zWydiYXNlRWxlbWVudCddKSB7XG4gICAgY29uc3QgYmFzZUVsZW1lbnQgPSBvcHRpb25zWydiYXNlRWxlbWVudCddO1xuICAgIHNldChcbiAgICAgIG9wdGlvbnMsXG4gICAgICBbJ2Jhc2VFbGVtZW50cycsICdzZWxlY3RvcnMnXSxcbiAgICAgIChBcnJheS5pc0FycmF5KGJhc2VFbGVtZW50KSA/IGJhc2VFbGVtZW50IDogW2Jhc2VFbGVtZW50XSlcbiAgICApO1xuICB9XG4gIGlmIChvcHRpb25zWydyZXR1cm5Eb21CeURlZmF1bHQnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc2V0KG9wdGlvbnMsIFsnYmFzZUVsZW1lbnRzJywgJ3JldHVybkRvbUJ5RGVmYXVsdCddLCBvcHRpb25zWydyZXR1cm5Eb21CeURlZmF1bHQnXSk7XG4gIH1cblxuICBmb3IgKGNvbnN0IGRlZmluaXRpb24gb2Ygb3B0aW9ucy5zZWxlY3RvcnMpIHtcbiAgICBpZiAoZGVmaW5pdGlvbi5mb3JtYXQgPT09ICdhbmNob3InICYmIGdldChkZWZpbml0aW9uLCBbJ29wdGlvbnMnLCAnbm9MaW5rQnJhY2tldHMnXSkpIHtcbiAgICAgIHNldChkZWZpbml0aW9uLCBbJ29wdGlvbnMnLCAnbGlua0JyYWNrZXRzJ10sIGZhbHNlKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5jb21waWxlID0gY29tcGlsZTtcbmV4cG9ydHMuY29udmVydCA9IGNvbnZlcnQ7XG5leHBvcnRzLmh0bWxUb1RleHQgPSBjb252ZXJ0O1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwicGx1Z2luSHRtbHBhcnNlcjIiLCJyZXF1aXJlIiwiaHRtbHBhcnNlcjIiLCJzZWxkZXJlZSIsIm1lcmdlIiwiZG9tU2VyaWFsaXplciIsIl9pbnRlcm9wRGVmYXVsdExlZ2FjeSIsImUiLCJtZXJnZV9fZGVmYXVsdCIsImxpbWl0ZWREZXB0aFJlY3Vyc2l2ZSIsIm4iLCJmIiwiZyIsInVuZGVmaW5lZCIsImYxIiwiYXJncyIsInRyaW1DaGFyYWN0ZXIiLCJzdHIiLCJjaGFyIiwic3RhcnQiLCJlbmQiLCJsZW5ndGgiLCJzdWJzdHJpbmciLCJ0cmltQ2hhcmFjdGVyRW5kIiwidW5pY29kZUVzY2FwZSIsInJlcGxhY2UiLCJjIiwiY2hhckNvZGVBdCIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJtZXJnZUR1cGxpY2F0ZXNQcmVmZXJMYXN0IiwiaXRlbXMiLCJnZXRLZXkiLCJtYXAiLCJNYXAiLCJpIiwiaXRlbSIsImtleSIsInNldCIsImhhcyIsImdldCIsImFycmF5TWVyZ2UiLCJvdmVyd3JpdGVNZXJnZSQxIiwidmFsdWVzIiwicmV2ZXJzZSIsImFjYyIsInNyYyIsIm9wdGlvbnMiLCJvYmoiLCJwYXRoIiwibnVtYmVyVG9MZXR0ZXJTZXF1ZW5jZSIsIm51bSIsImJhc2VDaGFyIiwiYmFzZSIsImRpZ2l0cyIsInB1c2giLCJiYXNlQ29kZSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImpvaW4iLCJJIiwiViIsIm51bWJlclRvUm9tYW4iLCJ2IiwicmVwZWF0IiwiSW5saW5lVGV4dEJ1aWxkZXIiLCJjb25zdHJ1Y3RvciIsIm1heExpbmVMZW5ndGgiLCJsaW5lcyIsIm5leHRMaW5lV29yZHMiLCJ3b3Jkd3JhcCIsIk51bWJlciIsIk1BWF9WQUxVRSIsIm5leHRMaW5lQXZhaWxhYmxlQ2hhcnMiLCJ3cmFwQ2hhcmFjdGVycyIsImZvcmNlV3JhcE9uTGltaXQiLCJzdGFzaGVkU3BhY2UiLCJ3b3JkQnJlYWtPcHBvcnR1bml0eSIsInB1c2hXb3JkIiwid29yZCIsIm5vV3JhcCIsInN0YXJ0TmV3TGluZSIsImlzTGluZVN0YXJ0IiwiY29zdCIsImZpcnN0IiwicmVzdCIsInNwbGl0TG9uZ1dvcmQiLCJwYXJ0IiwicG9wV29yZCIsImxhc3RXb3JkIiwicG9wIiwiY29uY2F0V29yZCIsImNvbmNhdCIsIkFycmF5IiwiZnJvbSIsImlzRW1wdHkiLCJjbGVhciIsIndvcmRzIiwicGFydHMiLCJpZHgiLCJmaXJzdExpbmUiLCJyZW1haW5pbmdDaGFycyIsInNwbGl0SW5kZXgiLCJsYXN0SW5kZXhPZiIsIlN0YWNrSXRlbSIsIm5leHQiLCJnZXRSb290IiwiQmxvY2tTdGFja0l0ZW0iLCJsZWFkaW5nTGluZUJyZWFrcyIsImlubGluZVRleHRCdWlsZGVyIiwicmF3VGV4dCIsInN0YXNoZWRMaW5lQnJlYWtzIiwiaXNQcmUiLCJpc05vV3JhcCIsIkxpc3RTdGFja0l0ZW0iLCJpbnRlclJvd0xpbmVCcmVha3MiLCJtYXhQcmVmaXhMZW5ndGgiLCJwcmVmaXhBbGlnbiIsIkxpc3RJdGVtU3RhY2tJdGVtIiwicHJlZml4IiwiVGFibGVTdGFja0l0ZW0iLCJyb3dzIiwiVGFibGVSb3dTdGFja0l0ZW0iLCJjZWxscyIsIlRhYmxlQ2VsbFN0YWNrSXRlbSIsIm1heENvbHVtbldpZHRoIiwiVHJhbnNmb3JtZXJTdGFja0l0ZW0iLCJ0cmFuc2Zvcm0iLCJjaGFyYWN0ZXJzVG9Db2RlcyIsIldoaXRlc3BhY2VQcm9jZXNzb3IiLCJ3aGl0ZXNwYWNlQ2hhcnMiLCJwcmVzZXJ2ZU5ld2xpbmVzIiwid2hpdGVzcGFjZUNoYXJhY3RlcnMiLCJ3aGl0ZXNwYWNlQ29kZXMiLCJsZWFkaW5nV2hpdGVzcGFjZVJlIiwiUmVnRXhwIiwidHJhaWxpbmdXaGl0ZXNwYWNlUmUiLCJhbGxXaGl0ZXNwYWNlT3JFbXB0eVJlIiwibmV3bGluZU9yTm9uV2hpdGVzcGFjZVJlIiwibmV3bGluZU9yTm9uTmV3bGluZVN0cmluZ1JlIiwid29yZE9yTmV3bGluZVJlIiwic2hyaW5rV3JhcEFkZCIsInRleHQiLCJwcmV2aW91c2x5U3Rhc2hlZFNwYWNlIiwiYW55TWF0Y2giLCJtIiwiZXhlYyIsInRlc3RMZWFkaW5nV2hpdGVzcGFjZSIsInRlc3RUcmFpbGluZ1doaXRlc3BhY2UiLCJ3b3JkUmUiLCJhZGRMaXRlcmFsIiwidGVzdCIsInRlc3RDb250YWluc1dvcmRzIiwiY291bnROZXdsaW5lc05vV29yZHMiLCJsYXN0SW5kZXgiLCJjb3VudGVyIiwibWF0Y2giLCJCbG9ja1RleHRCdWlsZGVyIiwicGlja2VyIiwibWV0YWRhdGEiLCJ3aGl0ZXNwYWNlUHJvY2Vzc29yIiwiX3N0YWNrSXRlbSIsIl93b3JkVHJhbnNmb3JtZXIiLCJwdXNoV29yZFRyYW5zZm9ybSIsIndvcmRUcmFuc2Zvcm0iLCJwb3BXb3JkVHJhbnNmb3JtIiwic3RhcnROb1dyYXAiLCJzdG9wTm9XcmFwIiwiX2dldENvbWJpbmVkV29yZFRyYW5zZm9ybWVyIiwid3QiLCJhcHBseVRyYW5zZm9ybWVyIiwiY2UiLCJlbmNvZGVDaGFyYWN0ZXJzIiwiX3BvcFN0YWNrSXRlbSIsImFkZExpbmVCcmVhayIsImFkZFdvcmRCcmVha09wcG9ydHVuaXR5IiwiYWRkSW5saW5lIiwibm9Xb3JkVHJhbnNmb3JtIiwibmV3bGluZXNOdW1iZXIiLCJvcGVuQmxvY2siLCJyZXNlcnZlZExpbmVMZW5ndGgiLCJNYXRoIiwibWF4IiwiY2xvc2VCbG9jayIsInRyYWlsaW5nTGluZUJyZWFrcyIsImJsb2NrVHJhbnNmb3JtIiwiYmxvY2siLCJibG9ja1RleHQiLCJnZXRUZXh0IiwiYWRkVGV4dCIsIm9wZW5MaXN0Iiwib3Blbkxpc3RJdGVtIiwiRXJyb3IiLCJsaXN0IiwicHJlZml4TGVuZ3RoIiwiY2xvc2VMaXN0SXRlbSIsImxpc3RJdGVtIiwic3BhY2luZyIsInBhZEVuZCIsImNsb3NlTGlzdCIsIm9wZW5UYWJsZSIsIm9wZW5UYWJsZVJvdyIsIm9wZW5UYWJsZUNlbGwiLCJjbG9zZVRhYmxlQ2VsbCIsImNvbHNwYW4iLCJyb3dzcGFuIiwiY2VsbCIsImNsb3NlVGFibGVSb3ciLCJyb3ciLCJjbG9zZVRhYmxlIiwidGFibGVUb1N0cmluZyIsInRhYmxlIiwib3V0cHV0Iiwic3RhY2tJdGVtIiwicGFyZW50VGV4dCIsImxpbmVCcmVha3MiLCJ0cmFuc2Zvcm1lciIsImNvbXBpbGUkMSIsInNlbGVjdG9yc1dpdGhvdXRGb3JtYXQiLCJzZWxlY3RvcnMiLCJmaWx0ZXIiLCJzIiwiZm9ybWF0Iiwic2VsZWN0b3IiLCJEZWNpc2lvblRyZWUiLCJidWlsZCIsImhwMkJ1aWxkZXIiLCJtYWtlUmVwbGFjZXJGcm9tRGljdCIsImJhc2VTZWxlY3RvcnNQaWNrZXIiLCJiYXNlRWxlbWVudHMiLCJmaW5kQmFzZUVsZW1lbnRzIiwiZG9tIiwiZmluZEJhc2VzIiwibGltaXRlZFdhbGsiLCJsaW1pdHMiLCJtYXhEZXB0aCIsInJlY3Vyc2l2ZVdhbGsiLCJidWlsZGVyIiwiZWxsaXBzaXMiLCJodG1sIiwicHJvY2VzcyIsIndhbGsiLCJtYXhJbnB1dExlbmd0aCIsImNvbnNvbGUiLCJ3YXJuIiwiZG9jdW1lbnQiLCJwYXJzZURvY3VtZW50IiwiZGVjb2RlRW50aXRpZXMiLCJiYXNlcyIsImNoaWxkcmVuIiwicmVzdWx0cyIsInNsaWNlIiwibWF4Q2hpbGROb2RlcyIsImVsZW0iLCJ0eXBlIiwicGlja2VkU2VsZWN0b3JJbmRleCIsInBpY2sxIiwic2VsZWN0b3JJbmRleCIsImVsZW1lbnQiLCJtYXhCYXNlRWxlbWVudHMiLCJvcmRlckJ5Iiwic29ydCIsImEiLCJiIiwicmV0dXJuRG9tQnlEZWZhdWx0IiwieCIsInRvb01hbnlDaGlsZE5vZGVzIiwiZGF0YSIsInRhZ0RlZmluaXRpb24iLCJmb3JtYXR0ZXJzIiwiZGljdCIsImtleXMiLCJlbnRyaWVzIiwicmVnZXgiLCJyZXBsYWNlciIsImNncyIsImZpbmRJbmRleCIsImNnIiwiZm9ybWF0U2tpcCIsImZvcm1hdE9wdGlvbnMiLCJmb3JtYXRJbmxpbmVTdHJpbmciLCJzdHJpbmciLCJmb3JtYXRCbG9ja1N0cmluZyIsImZvcm1hdElubGluZSIsImZvcm1hdEJsb2NrJDEiLCJyZW5kZXJPcGVuVGFnIiwiYXR0cnMiLCJhdHRyaWJzIiwiayIsIm5hbWUiLCJyZW5kZXJDbG9zZVRhZyIsImZvcm1hdElubGluZVRhZyIsImZvcm1hdEJsb2NrVGFnIiwiZm9ybWF0SW5saW5lSHRtbCIsInJlbmRlciIsImZvcm1hdEJsb2NrSHRtbCIsImZvcm1hdElubGluZVN1cnJvdW5kIiwic3VmZml4IiwiZ2VuZXJpY0Zvcm1hdHRlcnMiLCJmcmVlemUiLCJfX3Byb3RvX18iLCJibG9ja0h0bWwiLCJibG9ja1N0cmluZyIsImJsb2NrVGFnIiwiaW5saW5lIiwiaW5saW5lSHRtbCIsImlubGluZVN0cmluZyIsImlubGluZVN1cnJvdW5kIiwiaW5saW5lVGFnIiwic2tpcCIsImdldFJvdyIsIm1hdHJpeCIsImoiLCJmaW5kRmlyc3RWYWNhbnRJbmRleCIsInRyYW5zcG9zZUluUGxhY2UiLCJtYXhTaXplIiwicm93SSIsInJvd0oiLCJ0ZW1wIiwicHV0Q2VsbEludG9MYXlvdXQiLCJsYXlvdXQiLCJiYXNlUm93IiwiYmFzZUNvbCIsInIiLCJsYXlvdXRSb3ciLCJnZXRPckluaXRPZmZzZXQiLCJvZmZzZXRzIiwiaW5kZXgiLCJ1cGRhdGVPZmZzZXQiLCJzcGFuIiwidGFibGVSb3dzIiwicm93U3BhY2luZyIsImNvbFNwYWNpbmciLCJjb2xOdW1iZXIiLCJyb3dOdW1iZXIiLCJyb3dPZmZzZXRzIiwic3BsaXQiLCJjZWxsSGVpZ2h0Iiwib3V0cHV0TGluZXMiLCJjb2xPZmZzZXRzIiwieSIsInJvd3NJblRoaXNDb2x1bW4iLCJtaW4iLCJyZW5kZXJlZCIsImNlbGxXaWR0aCIsImxpbmUiLCJsaW5lT2Zmc2V0IiwiZm9ybWF0TGluZUJyZWFrIiwiZm9ybWF0V2JyIiwiZm9ybWF0SG9yaXpvbnRhbExpbmUiLCJmb3JtYXRQYXJhZ3JhcGgiLCJmb3JtYXRQcmUiLCJmb3JtYXRIZWFkaW5nIiwidXBwZXJjYXNlIiwidG9VcHBlckNhc2UiLCJmb3JtYXRCbG9ja3F1b3RlIiwidHJpbUVtcHR5TGluZXMiLCJ3aXRoQnJhY2tldHMiLCJicmFja2V0cyIsImxiciIsInJiciIsInBhdGhSZXdyaXRlIiwicmV3cml0ZXIiLCJiYXNlVXJsIiwibW9kaWZpZWRQYXRoIiwiZm9ybWF0SW1hZ2UiLCJhbHQiLCJsaW5rQnJhY2tldHMiLCJmb3JtYXRBbmNob3IiLCJnZXRIcmVmIiwiaWdub3JlSHJlZiIsImhyZWYiLCJub0FuY2hvclVybCIsImhpZGVTYW1lTGluayIsImhpZGVMaW5rSHJlZklmU2FtZUFzVGV4dCIsImZvcm1hdExpc3QiLCJuZXh0UHJlZml4Q2FsbGJhY2siLCJpc05lc3RlZExpc3QiLCJsaXN0SXRlbXMiLCJjaGlsZCIsIm5vZGUiLCJ0cmltU3RhcnQiLCJmb3JtYXRVbm9yZGVyZWRMaXN0IiwiaXRlbVByZWZpeCIsImZvcm1hdE9yZGVyZWRMaXN0IiwibmV4dEluZGV4IiwiaW5kZXhGdW5jdGlvbiIsImdldE9yZGVyZWRMaXN0SW5kZXhGdW5jdGlvbiIsIm9sVHlwZSIsInRvTG93ZXJDYXNlIiwic3BsaXRDbGFzc2VzQW5kSWRzIiwiY2xhc3NlcyIsImlkcyIsInN0YXJ0c1dpdGgiLCJpc0RhdGFUYWJsZSIsImF0dHIiLCJ0YWJsZXMiLCJhdHRyQ2xhc3NlcyIsImF0dHJJZHMiLCJzb21lIiwiaW5jbHVkZXMiLCJmb3JtYXRUYWJsZSIsImZvcm1hdERhdGFUYWJsZSIsImZvcm1hdEJsb2NrIiwiZm9yRWFjaCIsIndhbGtUYWJsZSIsImZvcm1hdENlbGwiLCJjZWxsTm9kZSIsImZvcm1hdEhlYWRlckNlbGwiLCJ1cHBlcmNhc2VIZWFkZXJDZWxscyIsImNoaWxkT2ZUciIsInRleHRGb3JtYXR0ZXJzIiwiYW5jaG9yIiwiYmxvY2txdW90ZSIsImRhdGFUYWJsZSIsImhlYWRpbmciLCJob3Jpem9udGFsTGluZSIsImltYWdlIiwibGluZUJyZWFrIiwib3JkZXJlZExpc3QiLCJwYXJhZ3JhcGgiLCJwcmUiLCJ1bm9yZGVyZWRMaXN0Iiwid2JyIiwiREVGQVVMVF9PUFRJT05TIiwibG9uZ1dvcmRTcGxpdCIsImNvbmNhdE1lcmdlIiwib3ZlcndyaXRlTWVyZ2UiLCJzZWxlY3RvcnNNZXJnZSIsImNvbXBpbGUiLCJjdXN0b21NZXJnZSIsImFzc2lnbiIsImhhbmRsZURlcHJlY2F0ZWRPcHRpb25zIiwiY29udmVydCIsInRhZ3MiLCJ0YWdEZWZpbml0aW9ucyIsImRlZmluaXRpb24iLCJ2YWx1ZUtleSIsIm5lc3RlZCIsImJhc2VFbGVtZW50IiwiaXNBcnJheSIsImh0bWxUb1RleHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../../../node_modules/html-to-text/lib/html-to-text.cjs\n");

/***/ })

};
;